<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹œí—˜ ë¬¸ì œ ì—°ìŠµ ì„œë¹„ìŠ¤</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .exam-selector {
            margin-bottom: 30px;
        }

        .exam-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .exam-card {
            background: linear-gradient(145deg, #f0f4f8, #e2e8f0);
            border: none;
            border-radius: 12px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .exam-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            background: linear-gradient(145deg, #e2e8f0, #cbd5e0);
        }

        .exam-card h3 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .exam-card p {
            color: #718096;
            font-size: 0.95rem;
        }

        .question-container {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8fafc;
            border-radius: 12px;
            border-left: 5px solid #667eea;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .question-score {
            background: #38a169;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
            line-height: 1.7;
        }

        .sub-questions {
            margin-left: 20px;
            border-left: 3px solid #e2e8f0;
            padding-left: 20px;
        }

        .sub-question {
            margin-bottom: 20px;
        }

        .options {
            margin: 15px 0;
        }

        .option {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }

        .option:hover {
            background-color: #f1f5f9;
        }

        .option input {
            margin-right: 12px;
            transform: scale(1.2);
        }

        .option label {
            cursor: pointer;
            flex: 1;
        }

        .text-answer {
            width: 100%;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
            resize: vertical;
            min-height: 100px;
        }

        .text-answer:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-container {
            margin-top: 30px;
        }

        .score-display {
            text-align: center;
            padding: 30px;
            background: linear-gradient(145deg, #48bb78, #38a169);
            color: white;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .score-display h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .answer-review {
            margin-bottom: 25px;
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #cbd5e0;
        }

        .answer-review.correct {
            background: #f0fff4;
            border-left-color: #48bb78;
        }

        .answer-review.incorrect {
            background: #fff5f5;
            border-left-color: #f56565;
        }

        .answer-review.partial {
            background: #fffbf0;
            border-left-color: #ed8936;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status-badge.correct {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-badge.incorrect {
            background: #fed7d7;
            color: #742a2a;
        }

        .status-badge.partial {
            background: #feebc8;
            color: #744210;
        }

        .explanation {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #667eea;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        .api-key-input {
            margin-bottom: 20px;
            padding: 20px;
            background: #f0f4f8;
            border-radius: 10px;
        }

        .api-key-input input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .card {
                padding: 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“š ì‹œí—˜ ë¬¸ì œ ì—°ìŠµ ì„œë¹„ìŠ¤</h1>
            <p>ë‹¤ì–‘í•œ ìœ í˜•ì˜ ë¬¸ì œë¥¼ í’€ê³  ì‹¤ë ¥ì„ í–¥ìƒì‹œì¼œë³´ì„¸ìš”!</p>
        </div>

        <!-- ì „ì—­ ë¹„ë°€ë²ˆí˜¸ ë³´í˜¸ í™”ë©´ -->
        <div class="card" id="globalPasswordSection">
            <div style="text-align: center; padding: 40px 20px;">
                <h2>ğŸ” ì„œë¹„ìŠ¤ ì ‘ì†</h2>
                <p style="margin: 20px 0; color: #718096;">ì´ ì„œë¹„ìŠ¤ëŠ” ë¹„ë°€ë²ˆí˜¸ë¡œ ë³´í˜¸ë˜ê³  ìˆìŠµë‹ˆë‹¤.</p>
                <div style="max-width: 300px; margin: 0 auto;">
                    <input type="password" id="globalPasswordInput" placeholder="ì ‘ì† ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”" 
                           style="width: 100%; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; margin-bottom: 15px; text-align: center;">
                    <button class="btn" onclick="checkGlobalPassword()" style="width: 100%;">ğŸš€ ì ‘ì†í•˜ê¸°</button>
                    <div id="globalPasswordError" style="color: #e53e3e; margin-top: 10px; font-size: 0.9rem; display: none;">
                        âŒ ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.
                    </div>
                </div>
            </div>
        </div>

        <!-- ë©”ì¸ ì„œë¹„ìŠ¤ ì»¨í…Œì´ë„ˆ (ë¹„ë°€ë²ˆí˜¸ í™•ì¸ í›„ í‘œì‹œ) -->
        <div id="mainServiceContainer" class="hidden">

        <!-- API Key ì„¤ì • -->
        <div class="card api-key-input" id="apiKeySection">
            <h3>ğŸ”‘ OpenAI API í‚¤ ì„¤ì •</h3>
            <p>ì£¼ê´€ì‹ ë¬¸ì œ ì±„ì ì„ ìœ„í•´ OpenAI API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.</p>
            <input type="password" id="apiKeyInput" placeholder="OpenAI API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”">
            <button class="btn" onclick="saveApiKey()">ì €ì¥</button>
            <button class="btn" onclick="showAdminLogin()" style="float: right; background: linear-gradient(145deg, #e53e3e, #c53030);">ğŸ”§ ê´€ë¦¬ì</button>
        </div>

        <!-- ê´€ë¦¬ì ë¡œê·¸ì¸ -->
        <div class="card hidden" id="adminLoginSection">
            <h3>ğŸ” ê´€ë¦¬ì ë¡œê·¸ì¸</h3>
            <p>ë¬¸ì œì§‘ ê´€ë¦¬ë¥¼ ìœ„í•´ ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</p>
            <input type="password" id="adminPasswordInput" placeholder="ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸">
            <button class="btn" onclick="adminLogin()">ë¡œê·¸ì¸</button>
            <button class="btn" onclick="hideAdminLogin()" style="background: #718096;">ì·¨ì†Œ</button>
        </div>

        <!-- ê´€ë¦¬ì íŒ¨ë„ -->
        <div class="card hidden" id="adminPanel">
            <h2>ğŸ› ï¸ ê´€ë¦¬ì íŒ¨ë„</h2>
            <div style="margin-bottom: 20px;">
                <button class="btn" onclick="showAddProblemSet()">â• ë¬¸ì œì§‘ ì¶”ê°€</button>
                <button class="btn" onclick="hideAdminPanel()" style="background: #718096;">ë‚˜ê°€ê¸°</button>
            </div>
            
            <!-- ë¬¸ì œì§‘ ëª©ë¡ -->
            <div id="adminProblemSetsList">
                <h3>ğŸ“š ì €ì¥ëœ ë¬¸ì œì§‘</h3>
                <div id="problemSetsManagement"></div>
            </div>
        </div>

        <!-- ë¬¸ì œì§‘ ì¶”ê°€/í¸ì§‘ í¼ -->
        <div class="card hidden" id="addProblemSetForm">
            <h3 id="formTitle">â• ìƒˆ ë¬¸ì œì§‘ ì¶”ê°€</h3>
            <div style="margin-bottom: 15px;">
                <label for="problemSetKey">ë¬¸ì œì§‘ í‚¤ (ì˜ë¬¸, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´ë§Œ):</label>
                <input type="text" id="problemSetKey" placeholder="ì˜ˆ: custom_math_1" style="width: 100%; padding: 10px; margin-top: 5px; border: 2px solid #e2e8f0; border-radius: 8px;">
            </div>
            <div style="margin-bottom: 15px;">
                <label for="problemSetJSON">JSON ë°ì´í„°:</label>
                <textarea id="problemSetJSON" rows="20" placeholder='JSON í˜•ì‹ìœ¼ë¡œ ë¬¸ì œì§‘ì„ ì…ë ¥í•˜ì„¸ìš”...' style="width: 100%; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; font-family: monospace; font-size: 0.9rem;"></textarea>
            </div>
            <div>
                <button class="btn" onclick="saveProblemSet()" id="saveBtn">ì €ì¥</button>
                <button class="btn" onclick="hideAddProblemSetForm()" style="background: #718096;">ì·¨ì†Œ</button>
                <button class="btn" onclick="showJSONExample()" style="background: #38a169;">ğŸ“„ ì˜ˆì‹œ ë³´ê¸°</button>
            </div>
        </div>

        <!-- ì‹œí—˜ ì„ íƒ í™”ë©´ -->
        <div class="card exam-selector" id="examSelector">
            <h2>ğŸ“‹ ì‹œí—˜ ì„ íƒ</h2>
            <div class="exam-grid" id="examGrid">
                <!-- ì‹œí—˜ ëª©ë¡ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
            </div>
        </div>

        <!-- ë¬¸ì œ í’€ì´ í™”ë©´ -->
        <div class="card hidden" id="examContainer">
            <div id="examHeader">
                <h2 id="examTitle"></h2>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p>ë¬¸ì œ <span id="currentQuestion">1</span> / <span id="totalQuestions">10</span></p>
            </div>
            
            <div id="questionContainer">
                <!-- ë¬¸ì œë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="submitAnswers()" id="submitBtn">ë‹µì•ˆ ì œì¶œ</button>
                <button class="btn" onclick="resetExam()">ì²˜ìŒìœ¼ë¡œ</button>
            </div>
        </div>

        <!-- ê²°ê³¼ í™”ë©´ -->
        <div class="card hidden" id="resultsContainer">
            <div class="score-display" id="scoreDisplay">
                <h2 id="finalScore"></h2>
                <p id="scoreDescription"></p>
            </div>
            
            <div id="answerReviews">
                <!-- ë‹µì•ˆ ê²€í† ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="resetExam()">ë‹¤ì‹œ ì‹œì‘</button>
            </div>
        </div>

        </div> <!-- End of mainServiceContainer -->
    </div>

    <script>
        // API ì„¤ì •
        const API_BASE_URL = window.location.hostname === 'localhost' ? '' : '';
        
        // ë¬¸ì œì§‘ ë°ì´í„° ì €ì¥ì†Œ
        let examData = {};
        let problemSetsIndex = null;

        let currentExam = null;
        let userAnswers = {};
        let apiKey = '';
        let isAdminLoggedIn = false;
        let editingProblemSetKey = null;
        let ADMIN_PASSWORD = 'admin123'; // ê¸°ë³¸ê°’, í™˜ê²½ë³€ìˆ˜ë¡œ ë®ì–´ì“°ê¸° ê°€ëŠ¥
        let GLOBAL_PASSWORD = ''; // ì „ì—­ ì ‘ì† ë¹„ë°€ë²ˆí˜¸
        let isGloballyAuthenticated = false;
        let authToken = null; // API ì¸ì¦ í† í°
        let shuffledOptionsMap = {}; // ì„ì¸ ì„ íƒì§€ì˜ ë§¤í•‘ì„ ì €ì¥
        
        // ì „ì—­ ë¹„ë°€ë²ˆí˜¸ í™•ì¸ í•¨ìˆ˜
        async function checkGlobalPassword() {
            const inputPassword = document.getElementById('globalPasswordInput').value.trim();
            const errorDiv = document.getElementById('globalPasswordError');
            
            if (!inputPassword) {
                showPasswordError('ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                // ì„œë²„ì—ì„œ ì¸ì¦ ì‹œë„
                const authResult = await apiCall('auth', {
                    method: 'POST',
                    body: JSON.stringify({ password: inputPassword })
                });

                if (authResult.success) {
                    authToken = authResult.token;
                    isGloballyAuthenticated = true;
                    
                    // ì¸ì¦ ì„±ê³µ ì‹œ ë©”ì¸ ì„œë¹„ìŠ¤ ë¡œë“œ
                    await initializeMainService();
                    
                    // UI ì „í™˜
                    document.getElementById('globalPasswordSection').classList.add('hidden');
                    document.getElementById('mainServiceContainer').classList.remove('hidden');
                    
                    // ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ì°½ ì´ˆê¸°í™”
                    document.getElementById('globalPasswordInput').value = '';
                    errorDiv.style.display = 'none';
                    
                } else {
                    showPasswordError('ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('Authentication failed:', error);
                showPasswordError('ì¸ì¦ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        function showPasswordError(message) {
            const errorDiv = document.getElementById('globalPasswordError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            // 3ì´ˆ í›„ ì—ëŸ¬ ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 3000);
        }

        // ë©”ì¸ ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        async function initializeMainService() {
            await loadEnvironmentVariables();
            updateApiKeyUI();
            await loadProblemSetsIndex();
            await loadExamList();
            renderMath();
        }

        // í™˜ê²½ë³€ìˆ˜ ë¡œë“œ í•¨ìˆ˜
        async function loadEnvironmentVariables() {
            try {
                // ì„œë²„ì—ì„œ í™˜ê²½ë³€ìˆ˜ ë¡œë“œ (ì¸ì¦ í† í° í¬í•¨)
                const config = await apiCall('config', {
                    headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {}
                });
                
                if (config.openaiApiKey) {
                    apiKey = config.openaiApiKey;
                    console.log('OpenAI API Key loaded from server environment variables');
                }
                
                if (config.adminPassword) {
                    ADMIN_PASSWORD = config.adminPassword;
                }
                
                if (config.globalPassword) {
                    GLOBAL_PASSWORD = config.globalPassword;
                }
                
            } catch (error) {
                console.error('Failed to load server configuration:', error);
                // Fallback to localStorage
                apiKey = localStorage.getItem('openai_api_key') || '';
            }
            
            // localStorageì—ì„œ ì‚¬ìš©ìê°€ ì…ë ¥í•œ í‚¤ê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©
            const storedApiKey = localStorage.getItem('openai_api_key');
            if (storedApiKey) {
                apiKey = storedApiKey;
                console.log('Using API key from localStorage (user override)');
            }
        }
        

        // ë°°ì—´ ì„ê¸° í•¨ìˆ˜ (Fisher-Yates shuffle)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // ì„ íƒì§€ ì„ê¸° ë° ë§¤í•‘ ìƒì„±
        function shuffleOptionsWithMapping(options, questionId) {
            const indexedOptions = options.map((option, index) => ({ option, originalIndex: index }));
            const shuffled = shuffleArray(indexedOptions);
            
            // ì›ë³¸ ì¸ë±ìŠ¤ -> ì„ì¸ ì¸ë±ìŠ¤ ë§¤í•‘
            const originalToShuffled = {};
            // ì„ì¸ ì¸ë±ìŠ¤ -> ì›ë³¸ ì¸ë±ìŠ¤ ë§¤í•‘
            const shuffledToOriginal = {};
            
            shuffled.forEach((item, newIndex) => {
                originalToShuffled[item.originalIndex] = newIndex;
                shuffledToOriginal[newIndex] = item.originalIndex;
            });
            
            shuffledOptionsMap[questionId] = {
                originalToShuffled,
                shuffledToOriginal,
                shuffledOptions: shuffled.map(item => item.option)
            };
            
            return shuffled.map(item => item.option);
        }

        // API í•¨ìˆ˜ë“¤
        async function apiCall(endpoint, options = {}) {
            try {
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                // ì¸ì¦ëœ ê²½ìš° í† í° ì¶”ê°€ (auth ì—”ë“œí¬ì¸íŠ¸ ì œì™¸)
                if (authToken && endpoint !== 'auth') {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE_URL}/api/${endpoint}`, {
                    headers,
                    ...options
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        async function loadProblemSetsIndex() {
            try {
                if (!authToken) {
                    console.error('No auth token available for API call');
                    return loadFallbackData();
                }
                
                problemSetsIndex = await apiCall('problem-sets');
                console.log('Problem sets index loaded successfully:', problemSetsIndex);
                return problemSetsIndex;
            } catch (error) {
                console.error('Failed to load problem sets index:', error);
                // Fallback to built-in data
                return loadFallbackData();
            }
        }

        async function loadProblemSet(key) {
            try {
                const problemSet = await apiCall(`problem-sets?key=${key}`);
                examData[key] = problemSet;
                return problemSet;
            } catch (error) {
                console.error(`Failed to load problem set ${key}:`, error);
                return null;
            }
        }

        async function saveProblemSetToAPI(key, data) {
            try {
                await apiCall('problem-sets', {
                    method: 'POST',
                    body: JSON.stringify({ key, data })
                });
                return true;
            } catch (error) {
                console.error('Failed to save problem set:', error);
                throw error;
            }
        }

        async function updateProblemSetInAPI(key, data) {
            try {
                await apiCall(`problem-sets?key=${key}`, {
                    method: 'PUT',
                    body: JSON.stringify({ data })
                });
                return true;
            } catch (error) {
                console.error('Failed to update problem set:', error);
                throw error;
            }
        }

        async function deleteProblemSetFromAPI(key) {
            try {
                await apiCall(`problem-sets?key=${key}`, {
                    method: 'DELETE'
                });
                return true;
            } catch (error) {
                console.error('Failed to delete problem set:', error);
                throw error;
            }
        }

        // Fallback ë°ì´í„° (API ì‹¤íŒ¨ ì‹œ ì‚¬ìš©)
        function loadFallbackData() {
            console.log('Using fallback data due to API failure');
            
            // ê¸°ë³¸ ë¬¸ì œì§‘ ë°ì´í„°ë¥¼ ì§ì ‘ ë¡œë“œ
            const fallbackMathData = {
                "title": "ê¸°ì´ˆ ìˆ˜í•™",
                "description": "ê¸°ë³¸ì ì¸ ìˆ˜í•™ ê°œë…ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œë“¤",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "ë‹¤ìŒ ì¤‘ $\\sqrt{16}$ì˜ ê°’ì€?",
                        "options": ["2", "4", "8", "16"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "$\\sqrt{16} = 4$ì…ë‹ˆë‹¤. 16ì˜ ì œê³±ê·¼ì€ 4ì…ë‹ˆë‹¤."
                    },
                    {
                        "id": 2,
                        "type": "multiple_choice",
                        "question": "ë‹¤ìŒ ì¤‘ ì†Œìˆ˜ì¸ ê²ƒì„ ëª¨ë‘ ê³ ë¥´ì„¸ìš”.",
                        "options": ["2", "3", "4", "5", "6", "7"],
                        "correct_answers": [0, 1, 3, 5],
                        "score": 15,
                        "explanation": "ì†Œìˆ˜ëŠ” 1ê³¼ ìê¸° ìì‹ ìœ¼ë¡œë§Œ ë‚˜ëˆ„ì–´ì§€ëŠ” ìì—°ìˆ˜ì…ë‹ˆë‹¤. 2, 3, 5, 7ì´ ì†Œìˆ˜ì…ë‹ˆë‹¤."
                    },
                    {
                        "id": 3,
                        "type": "true_false",
                        "question": "$\\pi$ëŠ” ë¬´ë¦¬ìˆ˜ì´ë‹¤.",
                        "correct_answer": true,
                        "score": 10,
                        "explanation": "$\\pi$ëŠ” ë¬´ë¦¬ìˆ˜ì…ë‹ˆë‹¤. ìœ í•œì†Œìˆ˜ë‚˜ ìˆœí™˜ì†Œìˆ˜ë¡œ í‘œí˜„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
                    }
                ]
            };
            
            const fallbackPhysicsData = {
                "title": "ê¸°ì´ˆ ë¬¼ë¦¬í•™",
                "description": "ë¬¼ë¦¬í•™ì˜ ê¸°ë³¸ ê°œë…ê³¼ ê³µì‹ë“¤",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "ììœ ë‚™í•˜í•˜ëŠ” ë¬¼ì²´ì˜ ê°€ì†ë„ëŠ” ëŒ€ëµ ì–¼ë§ˆì¸ê°€?",
                        "options": ["$9.8 \\text{ m/s}$", "$9.8 \\text{ m/s}^2$", "$98 \\text{ m/s}^2$", "$0.98 \\text{ m/s}^2$"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "ì§€êµ¬ì—ì„œ ì¤‘ë ¥ê°€ì†ë„ëŠ” ì•½ $9.8 \\text{ m/s}^2$ì…ë‹ˆë‹¤."
                    }
                ]
            };
            
            // examDataì— fallback ë°ì´í„° ë¡œë“œ
            examData['math_basic'] = fallbackMathData;
            examData['physics_basic'] = fallbackPhysicsData;
            
            return {
                version: "1.0.0",
                problem_sets: [
                    {
                        key: "math_basic",
                        title: "ê¸°ì´ˆ ìˆ˜í•™",
                        description: "ê¸°ë³¸ì ì¸ ìˆ˜í•™ ê°œë…ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œë“¤",
                        category: "mathematics",
                        is_built_in: true
                    },
                    {
                        key: "physics_basic",
                        title: "ê¸°ì´ˆ ë¬¼ë¦¬í•™", 
                        description: "ë¬¼ë¦¬í•™ì˜ ê¸°ë³¸ ê°œë…ê³¼ ê³µì‹ë“¤",
                        category: "physics",
                        is_built_in: true
                    }
                ]
            };
        }

        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', async function() {
            // ì „ì—­ ë¹„ë°€ë²ˆí˜¸ ë³´í˜¸ê°€ í™œì„±í™”ëœ ê²½ìš° ë¡œê·¸ì¸ í™”ë©´ í‘œì‹œ
            // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ë°”ë¡œ ë©”ì¸ ì„œë¹„ìŠ¤ ë¡œë“œ (í•„ìš”ì‹œ ì£¼ì„ í•´ì œ)
            // if (window.location.hostname === 'localhost') {
            //     await initializeMainService();
            //     document.getElementById('globalPasswordSection').classList.add('hidden');
            //     document.getElementById('mainServiceContainer').classList.remove('hidden');
            // }
            
            // Enter í‚¤ ì§€ì›
            document.getElementById('globalPasswordInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    checkGlobalPassword();
                }
            });
        });
        
        // API í‚¤ UI ì—…ë°ì´íŠ¸
        function updateApiKeyUI() {
            const apiKeyInput = document.getElementById('apiKeyInput');
            const apiKeySection = document.getElementById('apiKeySection');
            
            if (apiKey) {
                apiKeyInput.value = '***APIí‚¤ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤***';
                apiKeyInput.disabled = true;
                
                // í™˜ê²½ë³€ìˆ˜ì—ì„œ ë¡œë“œëœ ê²½ìš° ì•Œë¦¼ í‘œì‹œ
                const envSource = document.createElement('p');
                envSource.style.cssText = 'color: #38a169; font-size: 0.9rem; margin-top: 5px;';
                envSource.innerHTML = 'âœ… API í‚¤ê°€ í™˜ê²½ë³€ìˆ˜ì—ì„œ ìë™ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.';
                
                if (!document.querySelector('.env-source-notice')) {
                    envSource.className = 'env-source-notice';
                    apiKeySection.appendChild(envSource);
                }
            } else {
                // í™˜ê²½ë³€ìˆ˜ì—ì„œ ë¡œë“œë˜ì§€ ì•Šì€ ê²½ìš° ì‚¬ìš©ì ì…ë ¥ í—ˆìš©
                const notice = document.createElement('p');
                notice.style.cssText = 'color: #e53e3e; font-size: 0.9rem; margin-top: 5px;';
                notice.innerHTML = 'âš ï¸ í™˜ê²½ë³€ìˆ˜ì—ì„œ API í‚¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì§ì ‘ ì…ë ¥í•´ì£¼ì„¸ìš”.';
                notice.className = 'env-source-notice';
                apiKeySection.appendChild(notice);
            }
        }

        function renderMath() {
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ]
                });
            }
        }

        function saveApiKey() {
            const inputElement = document.getElementById('apiKeyInput');
            const key = inputElement.value.trim();
            
            // í™˜ê²½ë³€ìˆ˜ë¡œ ì´ë¯¸ ì„¤ì •ëœ ê²½ìš° ì‚¬ìš©ì ì…ë ¥ ë¬´ì‹œ
            if (inputElement.disabled) {
                alert('API í‚¤ê°€ ì´ë¯¸ í™˜ê²½ë³€ìˆ˜ì—ì„œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
                return;
            }
            
            if (key && key !== '***APIí‚¤ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤***') {
                apiKey = key;
                localStorage.setItem('openai_api_key', key);
                updateApiKeyUI();
                alert('API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else {
                alert('ìœ íš¨í•œ API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            }
        }

        // ê´€ë¦¬ì ê¸°ëŠ¥
        function showAdminLogin() {
            document.getElementById('adminLoginSection').classList.remove('hidden');
        }

        function hideAdminLogin() {
            document.getElementById('adminLoginSection').classList.add('hidden');
            document.getElementById('adminPasswordInput').value = '';
        }

        function adminLogin() {
            const password = document.getElementById('adminPasswordInput').value;
            if (password === ADMIN_PASSWORD) {
                isAdminLoggedIn = true;
                hideAdminLogin();
                showAdminPanel();
                loadProblemSetsManagement();
            } else {
                alert('ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.');
            }
        }

        function showAdminPanel() {
            document.getElementById('adminPanel').classList.remove('hidden');
        }

        function hideAdminPanel() {
            document.getElementById('adminPanel').classList.add('hidden');
            isAdminLoggedIn = false;
        }

        function showAddProblemSet() {
            editingProblemSetKey = null;
            document.getElementById('formTitle').textContent = 'â• ìƒˆ ë¬¸ì œì§‘ ì¶”ê°€';
            document.getElementById('problemSetKey').value = '';
            document.getElementById('problemSetJSON').value = '';
            document.getElementById('saveBtn').textContent = 'ì €ì¥';
            document.getElementById('addProblemSetForm').classList.remove('hidden');
        }

        function hideAddProblemSetForm() {
            document.getElementById('addProblemSetForm').classList.add('hidden');
            editingProblemSetKey = null;
        }

        function showJSONExample() {
            const example = {
                "title": "ì˜ˆì‹œ ë¬¸ì œì§‘",
                "description": "JSON í˜•ì‹ì˜ ì˜ˆì‹œ ë¬¸ì œì§‘ì…ë‹ˆë‹¤",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "2 + 2 = ?",
                        "options": ["3", "4", "5", "6"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "2 + 2 = 4ì…ë‹ˆë‹¤."
                    }
                ]
            };
            document.getElementById('problemSetJSON').value = JSON.stringify(example, null, 2);
        }

        async function saveProblemSet() {
            const key = document.getElementById('problemSetKey').value.trim();
            const jsonText = document.getElementById('problemSetJSON').value.trim();

            if (!key) {
                alert('ë¬¸ì œì§‘ í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(key)) {
                alert('ë¬¸ì œì§‘ í‚¤ëŠ” ì˜ë¬¸, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                return;
            }

            if (!jsonText) {
                alert('JSON ë°ì´í„°ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const problemSet = JSON.parse(jsonText);
                
                // ê¸°ë³¸ êµ¬ì¡° ê²€ì¦
                if (!problemSet.title || !problemSet.description || !problemSet.questions) {
                    alert('JSON í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. title, description, questions í•„ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                    return;
                }

                // APIì— ì €ì¥
                if (editingProblemSetKey) {
                    // í¸ì§‘ ëª¨ë“œ
                    await updateProblemSetInAPI(key, problemSet);
                    examData[key] = problemSet; // ë¡œì»¬ ìºì‹œ ì—…ë°ì´íŠ¸
                } else {
                    // ìƒˆë¡œ ìƒì„±
                    await saveProblemSetToAPI(key, problemSet);
                    examData[key] = problemSet; // ë¡œì»¬ ìºì‹œì— ì¶”ê°€
                }

                alert('ë¬¸ì œì§‘ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                hideAddProblemSetForm();
                await loadProblemSetsIndex(); // ì¸ë±ìŠ¤ ìƒˆë¡œê³ ì¹¨
                await loadProblemSetsManagement();
                await loadExamList(); // ì‹œí—˜ ëª©ë¡ ìƒˆë¡œê³ ì¹¨

            } catch (error) {
                if (error.message.includes('already exists')) {
                    alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë¬¸ì œì§‘ í‚¤ì…ë‹ˆë‹¤.');
                } else {
                    alert('ë¬¸ì œì§‘ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }
        }

        function getCustomProblemSets() {
            // For backward compatibility, check localStorage
            const stored = localStorage.getItem('custom_problem_sets');
            return stored ? JSON.parse(stored) : {};
        }

        function getAllProblemSets() {
            return examData;
        }

        function editProblemSet(key) {
            const allSets = getAllProblemSets();
            const problemSet = allSets[key];
            
            if (!problemSet) {
                alert('ë¬¸ì œì§‘ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            editingProblemSetKey = key;
            document.getElementById('formTitle').textContent = 'âœï¸ ë¬¸ì œì§‘ í¸ì§‘';
            document.getElementById('problemSetKey').value = key;
            document.getElementById('problemSetJSON').value = JSON.stringify(problemSet, null, 2);
            document.getElementById('saveBtn').textContent = 'ìˆ˜ì • ì €ì¥';
            document.getElementById('addProblemSetForm').classList.remove('hidden');
        }

        async function deleteProblemSet(key) {
            const problemSetInfo = problemSetsIndex.problem_sets.find(ps => ps.key === key);
            
            if (problemSetInfo && problemSetInfo.is_built_in) {
                alert('ê¸°ë³¸ ë¬¸ì œì§‘ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            if (confirm(`'${key}' ë¬¸ì œì§‘ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                try {
                    await deleteProblemSetFromAPI(key);
                    delete examData[key]; // ë¡œì»¬ ìºì‹œì—ì„œ ì œê±°
                    
                    await loadProblemSetsIndex(); // ì¸ë±ìŠ¤ ìƒˆë¡œê³ ì¹¨
                    await loadProblemSetsManagement();
                    await loadExamList(); // ì‹œí—˜ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    alert('ë¬¸ì œì§‘ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                } catch (error) {
                    alert('ë¬¸ì œì§‘ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }
        }

        async function loadProblemSetsManagement() {
            const container = document.getElementById('problemSetsManagement');
            container.innerHTML = '';
            
            if (!problemSetsIndex) {
                container.innerHTML = '<p>ë¬¸ì œì§‘ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>';
                return;
            }
            
            for (const problemSetInfo of problemSetsIndex.problem_sets) {
                const key = problemSetInfo.key;
                const exam = examData[key];
                
                if (!exam) {
                    // ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì€ ë¬¸ì œì§‘ì€ ë¡œë“œ
                    await loadProblemSet(key);
                }
                
                const setDiv = document.createElement('div');
                setDiv.style.cssText = 'border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; margin: 10px 0; background: #f8fafc;';
                
                const questionCount = examData[key] ? getTotalQuestionCount(examData[key].questions) : '?';
                
                setDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4>${problemSetInfo.title} ${problemSetInfo.is_built_in ? '(ê¸°ë³¸)' : '(ì»¤ìŠ¤í…€)'}</h4>
                            <p style="color: #718096; margin: 5px 0;">${problemSetInfo.description}</p>
                            <small style="color: #a0aec0;">í‚¤: ${key} | ë¬¸ì œ ìˆ˜: ${questionCount}</small>
                        </div>
                        <div>
                            <button onclick="editProblemSet('${key}')" style="background: #4299e1; color: white; border: none; padding: 8px 12px; border-radius: 4px; margin: 0 5px; cursor: pointer;">í¸ì§‘</button>
                            ${!problemSetInfo.is_built_in ? `<button onclick="deleteProblemSet('${key}')" style="background: #e53e3e; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">ì‚­ì œ</button>` : ''}
                        </div>
                    </div>
                `;
                
                container.appendChild(setDiv);
            }
        }

        async function loadExamList() {
            const examGrid = document.getElementById('examGrid');
            examGrid.innerHTML = '';

            if (!problemSetsIndex || !problemSetsIndex.problem_sets) {
                console.log('Problem sets index not available, trying to reload...');
                
                // Try to reload the problem sets index
                try {
                    problemSetsIndex = await loadProblemSetsIndex();
                } catch (error) {
                    console.error('Failed to reload problem sets index:', error);
                    examGrid.innerHTML = '<p style="color: #e53e3e;">ë¬¸ì œì§‘ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨í•´ë³´ì„¸ìš”.</p>';
                    return;
                }
                
                if (!problemSetsIndex || !problemSetsIndex.problem_sets) {
                    examGrid.innerHTML = '<p style="color: #e53e3e;">ë¬¸ì œì§‘ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
                    return;
                }
            }

            console.log('Loading exam list with', problemSetsIndex.problem_sets.length, 'problem sets');

            for (const problemSetInfo of problemSetsIndex.problem_sets) {
                const key = problemSetInfo.key;
                
                const examCard = document.createElement('div');
                examCard.className = 'exam-card';
                examCard.onclick = () => startExam(key);
                
                examCard.innerHTML = `
                    <h3>${problemSetInfo.title}</h3>
                    <p>${problemSetInfo.description}</p>
                    <p><strong>ì¹´í…Œê³ ë¦¬:</strong> ${problemSetInfo.category || 'general'}</p>
                `;
                
                examGrid.appendChild(examCard);
            }
        }

        function getTotalQuestionCount(questions) {
            let count = 0;
            questions.forEach(q => {
                if (q.type === 'compound') {
                    count += q.sub_questions.length;
                } else {
                    count += 1;
                }
            });
            return count;
        }

        async function startExam(examKey) {
            // ë¬¸ì œì§‘ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë¡œë“œ
            if (!examData[examKey]) {
                await loadProblemSet(examKey);
            }
            
            currentExam = examData[examKey];
            if (!currentExam) {
                alert('ë¬¸ì œì§‘ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            userAnswers = {};
            shuffledOptionsMap = {}; // ì„ì¸ ì„ íƒì§€ ë§¤í•‘ ì´ˆê¸°í™”
            
            document.getElementById('examSelector').classList.add('hidden');
            document.getElementById('examContainer').classList.remove('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            
            document.getElementById('examTitle').textContent = currentExam.title;
            document.getElementById('totalQuestions').textContent = getTotalQuestionCount(currentExam.questions);
            
            renderQuestions();
            updateProgress();
        }

        function renderQuestions() {
            const container = document.getElementById('questionContainer');
            container.innerHTML = '';
            
            let questionNumber = 1;
            
            currentExam.questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question-container';
                
                if (question.type === 'compound') {
                    questionDiv.innerHTML = `
                        <div class="question-header">
                            <span class="question-number">${questionNumber}</span>
                            <span class="question-score">${question.score}ì </span>
                        </div>
                        <div class="question-text">${question.question}</div>
                        <div class="sub-questions">
                            ${question.sub_questions.map((subQ, subIndex) => {
                                const subQuestionHtml = renderSubQuestion(subQ, `${question.id}-${subIndex}`, questionNumber + subIndex);
                                return `<div class="sub-question">${subQuestionHtml}</div>`;
                            }).join('')}
                        </div>
                    `;
                    questionNumber += question.sub_questions.length;
                } else {
                    questionDiv.innerHTML = renderSingleQuestion(question, questionNumber);
                    questionNumber++;
                }
                
                container.appendChild(questionDiv);
            });
            
            setTimeout(renderMath, 100);
        }

        function renderSingleQuestion(question, questionNumber) {
            const questionId = question.id;
            
            let optionsHtml = '';
            
            switch (question.type) {
                case 'single_choice':
                    const shuffledSingleOptions = shuffleOptionsWithMapping(question.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSingleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="radio" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'multiple_choice':
                    const shuffledMultipleOptions = shuffleOptionsWithMapping(question.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledMultipleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="checkbox" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'true_false':
                    optionsHtml = `
                        <div class="options">
                            <div class="option">
                                <input type="radio" id="q${questionId}_true" name="q${questionId}" value="true">
                                <label for="q${questionId}_true">ì°¸</label>
                            </div>
                            <div class="option">
                                <input type="radio" id="q${questionId}_false" name="q${questionId}" value="false">
                                <label for="q${questionId}_false">ê±°ì§“</label>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'short_answer':
                case 'essay':
                    optionsHtml = `
                        <textarea class="text-answer" id="q${questionId}" placeholder="ë‹µì•ˆì„ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
                    `;
                    break;
            }
            
            return `
                <div class="question-header">
                    <span class="question-number">${questionNumber}</span>
                    <span class="question-score">${question.score}ì </span>
                </div>
                <div class="question-text">${question.question}</div>
                ${optionsHtml}
            `;
        }

        function renderSubQuestion(subQuestion, questionId, questionNumber) {
            let optionsHtml = '';
            
            switch (subQuestion.type) {
                case 'single_choice':
                    const shuffledSubSingleOptions = shuffleOptionsWithMapping(subQuestion.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSubSingleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="radio" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'multiple_choice':
                    const shuffledSubMultipleOptions = shuffleOptionsWithMapping(subQuestion.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSubMultipleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="checkbox" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'true_false':
                    optionsHtml = `
                        <div class="options">
                            <div class="option">
                                <input type="radio" id="q${questionId}_true" name="q${questionId}" value="true">
                                <label for="q${questionId}_true">ì°¸</label>
                            </div>
                            <div class="option">
                                <input type="radio" id="q${questionId}_false" name="q${questionId}" value="false">
                                <label for="q${questionId}_false">ê±°ì§“</label>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'short_answer':
                case 'essay':
                    optionsHtml = `
                        <textarea class="text-answer" id="q${questionId}" placeholder="ë‹µì•ˆì„ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
                    `;
                    break;
            }
            
            return `
                <div class="question-header">
                    <span class="question-number">${questionNumber}</span>
                    <span class="question-score">${subQuestion.score}ì </span>
                </div>
                <div class="question-text">${subQuestion.question}</div>
                ${optionsHtml}
            `;
        }

        function updateProgress() {
            document.getElementById('progressFill').style.width = '0%';
        }

        async function submitAnswers() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="loading"></span> ì±„ì  ì¤‘...';
            
            // ë‹µì•ˆ ìˆ˜ì§‘
            collectAnswers();
            
            // ì±„ì  ìˆ˜í–‰
            const results = await gradeAnswers();
            
            // ê²°ê³¼ í‘œì‹œ
            showResults(results);
            
            submitBtn.disabled = false;
            submitBtn.innerHTML = 'ë‹µì•ˆ ì œì¶œ';
        }

        function collectAnswers() {
            userAnswers = {};
            
            currentExam.questions.forEach((question, index) => {
                if (question.type === 'compound') {
                    question.sub_questions.forEach((subQ, subIndex) => {
                        const questionId = `${question.id}-${subIndex}`;
                        userAnswers[questionId] = collectSingleAnswer(subQ, questionId);
                    });
                } else {
                    userAnswers[question.id] = collectSingleAnswer(question, question.id);
                }
            });
        }

        function collectSingleAnswer(question, questionId) {
            switch (question.type) {
                case 'single_choice':
                    const radio = document.querySelector(`input[name="q${questionId}"]:checked`);
                    if (radio) {
                        const shuffledIndex = parseInt(radio.value);
                        // ì„ì¸ ì¸ë±ìŠ¤ë¥¼ ì›ë³¸ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
                        const mapping = shuffledOptionsMap[questionId];
                        return mapping ? mapping.shuffledToOriginal[shuffledIndex] : shuffledIndex;
                    }
                    return null;
                    
                case 'multiple_choice':
                    const checkboxes = document.querySelectorAll(`input[name="q${questionId}"]:checked`);
                    const shuffledIndices = Array.from(checkboxes).map(cb => parseInt(cb.value));
                    // ì„ì¸ ì¸ë±ìŠ¤ë“¤ì„ ì›ë³¸ ì¸ë±ìŠ¤ë“¤ë¡œ ë³€í™˜
                    const mapping = shuffledOptionsMap[questionId];
                    if (mapping) {
                        return shuffledIndices.map(index => mapping.shuffledToOriginal[index]);
                    }
                    return shuffledIndices;
                    
                case 'true_false':
                    const tfRadio = document.querySelector(`input[name="q${questionId}"]:checked`);
                    return tfRadio ? tfRadio.value : null;
                    
                case 'short_answer':
                case 'essay':
                    const textarea = document.getElementById(`q${questionId}`);
                    return textarea ? textarea.value.trim() : '';
                    
                default:
                    return null;
            }
        }

        async function gradeAnswers() {
            const results = {};
            
            for (const question of currentExam.questions) {
                if (question.type === 'compound') {
                    for (let subIndex = 0; subIndex < question.sub_questions.length; subIndex++) {
                        const subQ = question.sub_questions[subIndex];
                        const questionId = `${question.id}-${subIndex}`;
                        const userAnswer = userAnswers[questionId];
                        
                        if (subQ.type === 'essay') {
                            results[questionId] = await gradeEssayQuestion(subQ, userAnswer);
                        } else {
                            results[questionId] = gradeObjectiveQuestion(subQ, userAnswer);
                        }
                    }
                } else {
                    const questionId = question.id;
                    const userAnswer = userAnswers[questionId];
                    
                    if (question.type === 'essay') {
                        results[questionId] = await gradeEssayQuestion(question, userAnswer);
                    } else {
                        results[questionId] = gradeObjectiveQuestion(question, userAnswer);
                    }
                }
            }
            
            return results;
        }

        function gradeObjectiveQuestion(question, userAnswer) {
            let isCorrect = false;
            let score = 0;
            
            switch (question.type) {
                case 'single_choice':
                    isCorrect = parseInt(userAnswer) === question.correct_answer;
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'multiple_choice':
                    const correctAnswers = question.correct_answers.sort();
                    const userAnswersSorted = (userAnswer || []).sort();
                    isCorrect = JSON.stringify(correctAnswers) === JSON.stringify(userAnswersSorted);
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'true_false':
                    const correctAnswer = question.correct_answer.toString();
                    isCorrect = userAnswer === correctAnswer;
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'short_answer':
                    isCorrect = userAnswer && userAnswer.toLowerCase() === question.correct_answer.toLowerCase();
                    score = isCorrect ? question.score : 0;
                    break;
            }
            
            return {
                isCorrect,
                score,
                maxScore: question.score,
                userAnswer,
                correctAnswer: question.correct_answer || question.correct_answers,
                explanation: question.explanation
            };
        }

        async function gradeEssayQuestion(question, userAnswer) {
            if (!apiKey) {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer,
                    explanation: question.explanation,
                    feedback: "API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•„ ì£¼ê´€ì‹ ë¬¸ì œë¥¼ ì±„ì í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
                };
            }

            if (!userAnswer || userAnswer.trim() === '') {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer: '',
                    explanation: question.explanation,
                    feedback: "ë‹µì•ˆì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                };
            }

            // ë¸Œë¼ìš°ì € ì œí•œìœ¼ë¡œ ì¸í•´ ì§ì ‘ OpenAI API í˜¸ì¶œì´ ì–´ë ¤ìš°ë¯€ë¡œ 
            // ì„ì‹œë¡œ ê°„ë‹¨í•œ í‚¤ì›Œë“œ ê¸°ë°˜ ì±„ì ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
            return gradeEssaySimple(question, userAnswer);
        }

        function gradeEssaySimple(question, userAnswer) {
            // ê°„ë‹¨í•œ í‚¤ì›Œë“œ ê¸°ë°˜ ì±„ì  ì‹œìŠ¤í…œ
            const answerLower = userAnswer.toLowerCase();
            let score = 0;
            let feedback = "";
            
            // ê¸°ë³¸ ì ìˆ˜ (ë‹µì•ˆì„ ì‘ì„±í–ˆìœ¼ë©´ ê¸°ë³¸ì ìˆ˜ ë¶€ì—¬)
            if (userAnswer.length > 10) {
                score = Math.floor(question.score * 0.3); // 30% ê¸°ë³¸ì ìˆ˜
                feedback = "ë‹µì•ˆì„ ì„±ì‹¤íˆ ì‘ì„±í–ˆìŠµë‹ˆë‹¤. ";
            }
            
            // ë¬¸ì œë³„ í‚¤ì›Œë“œ ì±„ì 
            if (question.question.includes("í”¼íƒ€ê³ ë¼ìŠ¤")) {
                const keywords = ["aÂ²+bÂ²=cÂ²", "a^2+b^2=c^2", "ì§ê°ì‚¼ê°í˜•", "ë¹—ë³€", "ì œê³±", "ë£¨íŠ¸"];
                let keywordCount = 0;
                keywords.forEach(keyword => {
                    if (answerLower.includes(keyword.toLowerCase())) {
                        keywordCount++;
                    }
                });
                
                if (keywordCount >= 3) {
                    score = question.score; // ë§Œì 
                    feedback += "í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ë¥¼ ì •í™•íˆ ì´í•´í•˜ê³  ê³„ì‚°ì„ ì˜¬ë°”ë¥´ê²Œ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤.";
                } else if (keywordCount >= 2) {
                    score = Math.floor(question.score * 0.7); // 70%
                    feedback += "í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ì˜ ê°œë…ì€ ì´í•´í–ˆìœ¼ë‚˜ ì„¤ëª…ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.";
                } else if (keywordCount >= 1) {
                    score = Math.floor(question.score * 0.5); // 50%
                    feedback += "í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ì— ëŒ€í•œ ê¸°ë³¸ ì´í•´ëŠ” ìˆìœ¼ë‚˜ ë” ìì„¸í•œ ì„¤ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤.";
                }
            }
            
            else if (question.question.includes("ë‰´í„´") && question.question.includes("ì œ3ë²•ì¹™")) {
                const keywords = ["ì‘ìš©", "ë°˜ì‘ìš©", "ê°™ì€", "í¬ê¸°", "ë°˜ëŒ€", "ë°©í–¥", "í˜", "ë²•ì¹™"];
                let keywordCount = 0;
                keywords.forEach(keyword => {
                    if (answerLower.includes(keyword.toLowerCase())) {
                        keywordCount++;
                    }
                });
                
                if (keywordCount >= 4) {
                    score = question.score;
                    feedback += "ë‰´í„´ ì œ3ë²•ì¹™ì„ ì •í™•íˆ ì„¤ëª…í–ˆìŠµë‹ˆë‹¤.";
                } else if (keywordCount >= 2) {
                    score = Math.floor(question.score * 0.7);
                    feedback += "ë‰´í„´ ì œ3ë²•ì¹™ì˜ ê¸°ë³¸ ê°œë…ì€ ë§ìœ¼ë‚˜ ë” ì •í™•í•œ ì„¤ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤.";
                }
            }
            
            // ë‹µì•ˆ ê¸¸ì´ì— ë”°ë¥¸ ì¶”ê°€ ì ìˆ˜ ì¡°ì •
            if (userAnswer.length < 20) {
                score = Math.min(score, Math.floor(question.score * 0.4));
                feedback += " ë‹µì•ˆì´ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤.";
            } else if (userAnswer.length > 100) {
                feedback += " ìƒì„¸í•œ ë‹µì•ˆì„ ì‘ì„±í–ˆìŠµë‹ˆë‹¤.";
            }
            
            return {
                isCorrect: score === question.score,
                score: Math.min(score, question.score),
                maxScore: question.score,
                userAnswer,
                explanation: question.explanation,
                feedback: feedback || "ë‹µì•ˆì„ ê²€í† í•´ë³´ì„¸ìš”."
            };
        }

        // OpenAI API ì‚¬ìš©ì„ ìœ„í•œ í”„ë¡ì‹œ í•¨ìˆ˜ (ì„ íƒì‚¬í•­)
        async function gradeEssayWithAPI(question, userAnswer) {
            try {
                // CORS ìš°íšŒë¥¼ ìœ„í•œ í”„ë¡ì‹œ ì„œë¹„ìŠ¤ ì‚¬ìš© ì˜ˆì‹œ
                // ì‹¤ì œ ì‚¬ìš©ì‹œì—ëŠ” ìì²´ í”„ë¡ì‹œ ì„œë²„ êµ¬ì¶• ê¶Œì¥
                const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
                const targetUrl = 'https://api.openai.com/v1/chat/completions';
                
                const response = await fetch(proxyUrl + targetUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey,
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify({
                        model: 'gpt-3.5-turbo',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are an exam grader. Evaluate the student answer and respond with JSON: {"score": number, "feedback": "string", "isCorrect": boolean}'
                            },
                            {
                                role: 'user',
                                content: `Question: ${question.question}\nCorrect Answer Reference: ${question.explanation}\nStudent Answer: ${userAnswer}\nMax Score: ${question.score}`
                            }
                        ],
                        temperature: 0.3
                    })
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const data = await response.json();
                const aiResponse = JSON.parse(data.choices[0].message.content);
                
                return {
                    isCorrect: aiResponse.score === question.score,
                    score: aiResponse.score,
                    maxScore: question.score,
                    userAnswer,
                    explanation: question.explanation,
                    feedback: aiResponse.feedback
                };
            } catch (error) {
                console.error('AI grading error:', error);
                // API ì‹¤íŒ¨ì‹œ ê°„ë‹¨ ì±„ì ìœ¼ë¡œ fallback
                return gradeEssaySimple(question, userAnswer);
            }
        }

        function showResults(results) {
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.remove('hidden');
            
            let totalScore = 0;
            let maxTotalScore = 0;
            
            // ì ìˆ˜ ê³„ì‚°
            for (const result of Object.values(results)) {
                totalScore += result.score;
                maxTotalScore += result.maxScore;
            }
            
            // ì ìˆ˜ í‘œì‹œ
            const percentage = Math.round((totalScore / maxTotalScore) * 100);
            document.getElementById('finalScore').textContent = `${totalScore}/${maxTotalScore}ì  (${percentage}%)`;
            
            let scoreDescription = '';
            if (percentage >= 90) {
                scoreDescription = 'ğŸ‰ í›Œë¥­í•©ë‹ˆë‹¤! ë§¤ìš° ìš°ìˆ˜í•œ ì„±ì ì…ë‹ˆë‹¤.';
            } else if (percentage >= 80) {
                scoreDescription = 'ğŸ‘ ì˜í–ˆìŠµë‹ˆë‹¤! ì¢‹ì€ ì„±ì ì…ë‹ˆë‹¤.';
            } else if (percentage >= 70) {
                scoreDescription = 'ğŸ‘ ê´œì°®ìŠµë‹ˆë‹¤! ì¡°ê¸ˆë§Œ ë” ë…¸ë ¥í•˜ë©´ ë©ë‹ˆë‹¤.';
            } else if (percentage >= 60) {
                scoreDescription = 'ğŸ“š ë” ê³µë¶€ê°€ í•„ìš”í•©ë‹ˆë‹¤.';
            } else {
                scoreDescription = 'ğŸ’ª í¬ê¸°í•˜ì§€ ë§ê³  ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!';
            }
            document.getElementById('scoreDescription').textContent = scoreDescription;
            
            // ë‹µì•ˆ ê²€í†  í‘œì‹œ
            const reviewsContainer = document.getElementById('answerReviews');
            reviewsContainer.innerHTML = '';
            
            let questionNumber = 1;
            
            currentExam.questions.forEach((question) => {
                if (question.type === 'compound') {
                    const compoundDiv = document.createElement('div');
                    compoundDiv.innerHTML = `<h3>${question.question}</h3>`;
                    
                    question.sub_questions.forEach((subQ, subIndex) => {
                        const questionId = `${question.id}-${subIndex}`;
                        const result = results[questionId];
                        
                        const reviewDiv = createAnswerReview(subQ, result, questionNumber);
                        compoundDiv.appendChild(reviewDiv);
                        questionNumber++;
                    });
                    
                    reviewsContainer.appendChild(compoundDiv);
                } else {
                    const result = results[question.id];
                    const reviewDiv = createAnswerReview(question, result, questionNumber);
                    reviewsContainer.appendChild(reviewDiv);
                    questionNumber++;
                }
            });
            
            setTimeout(renderMath, 100);
        }

        function createAnswerReview(question, result, questionNumber) {
            const reviewDiv = document.createElement('div');
            
            let statusClass = 'incorrect';
            let statusText = 'í‹€ë¦¼';
            
            if (result.isCorrect) {
                statusClass = 'correct';
                statusText = 'ì •ë‹µ';
            } else if (result.score > 0) {
                statusClass = 'partial';
                statusText = 'ë¶€ë¶„ ì •ë‹µ';
            }
            
            reviewDiv.className = `answer-review ${statusClass}`;
            
            let userAnswerText = '';
            if (question.type === 'multiple_choice') {
                const selectedOptions = (result.userAnswer || []).map(index => question.options[index]);
                userAnswerText = selectedOptions.length > 0 ? selectedOptions.join(', ') : 'ì„ íƒí•˜ì§€ ì•ŠìŒ';
            } else if (question.type === 'single_choice') {
                userAnswerText = result.userAnswer !== null ? question.options[result.userAnswer] : 'ì„ íƒí•˜ì§€ ì•ŠìŒ';
            } else if (question.type === 'true_false') {
                userAnswerText = result.userAnswer === 'true' ? 'ì°¸' : result.userAnswer === 'false' ? 'ê±°ì§“' : 'ì„ íƒí•˜ì§€ ì•ŠìŒ';
            } else {
                userAnswerText = result.userAnswer || 'ë‹µì•ˆ ì—†ìŒ';
            }
            
            let correctAnswerText = '';
            if (question.type === 'multiple_choice') {
                correctAnswerText = question.correct_answers.map(index => question.options[index]).join(', ');
            } else if (question.type === 'single_choice') {
                correctAnswerText = question.options[question.correct_answer];
            } else if (question.type === 'true_false') {
                correctAnswerText = question.correct_answer ? 'ì°¸' : 'ê±°ì§“';
            } else if (question.type === 'short_answer') {
                correctAnswerText = question.correct_answer;
            } else {
                correctAnswerText = 'ì£¼ê´€ì‹ ë¬¸ì œ';
            }
            
            reviewDiv.innerHTML = `
                <div class="status-badge ${statusClass}">${statusText} (${result.score}/${result.maxScore}ì )</div>
                <h4>ë¬¸ì œ ${questionNumber}: ${question.question}</h4>
                <p><strong>ë‚´ ë‹µì•ˆ:</strong> ${userAnswerText}</p>
                ${question.type !== 'essay' ? `<p><strong>ì •ë‹µ:</strong> ${correctAnswerText}</p>` : ''}
                ${result.feedback ? `<p><strong>AI í”¼ë“œë°±:</strong> ${result.feedback}</p>` : ''}
                <div class="explanation">
                    <strong>í•´ì„¤:</strong> ${result.explanation}
                </div>
            `;
            
            return reviewDiv;
        }

        function resetExam() {
            currentExam = null;
            userAnswers = {};
            shuffledOptionsMap = {}; // ì„ì¸ ì„ íƒì§€ ë§¤í•‘ ì´ˆê¸°í™”
            
            document.getElementById('examSelector').classList.remove('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
        }
    </script>
</body>
</html>
