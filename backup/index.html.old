<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹œí—˜ ë¬¸ì œ ì—°ìŠµ ì„œë¹„ìŠ¤</title>
    <!-- JWT Auth Update -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .exam-selector {
            margin-bottom: 30px;
        }

        .exam-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .exam-card {
            background: linear-gradient(145deg, #f0f4f8, #e2e8f0);
            border: none;
            border-radius: 12px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .exam-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            background: linear-gradient(145deg, #e2e8f0, #cbd5e0);
        }

        .exam-card h3 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .exam-card p {
            color: #718096;
            font-size: 0.95rem;
        }

        .question-container {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8fafc;
            border-radius: 12px;
            border-left: 5px solid #667eea;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .question-score {
            background: #38a169;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
            line-height: 1.7;
        }

        .sub-questions {
            margin-left: 20px;
            border-left: 3px solid #e2e8f0;
            padding-left: 20px;
        }

        .sub-question {
            margin-bottom: 20px;
        }

        .options {
            margin: 15px 0;
        }

        .option {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }

        .option:hover {
            background-color: #f1f5f9;
        }

        .option input {
            margin-right: 12px;
            transform: scale(1.2);
        }

        .option label {
            cursor: pointer;
            flex: 1;
        }

        .text-answer {
            width: 100%;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
            resize: vertical;
            min-height: 100px;
        }

        .text-answer:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-container {
            margin-top: 30px;
        }

        .score-display {
            text-align: center;
            padding: 30px;
            background: linear-gradient(145deg, #48bb78, #38a169);
            color: white;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .score-display h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .answer-review {
            margin-bottom: 25px;
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #cbd5e0;
        }

        .answer-review.correct {
            background: #f0fff4;
            border-left-color: #48bb78;
        }

        .answer-review.incorrect {
            background: #fff5f5;
            border-left-color: #f56565;
        }

        .answer-review.partial {
            background: #fffbf0;
            border-left-color: #ed8936;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status-badge.correct {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-badge.incorrect {
            background: #fed7d7;
            color: #742a2a;
        }

        .status-badge.partial {
            background: #feebc8;
            color: #744210;
        }

        .explanation {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #667eea;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* New AI grading feedback styles */
        .method-badge {
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .method-badge.ai {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .method-badge.fallback {
            background: #f7fafc;
            color: #4a5568;
            border: 1px solid #e2e8f0;
        }
        
        .ai-feedback {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border-radius: 8px;
            border-left: 4px solid #0ea5e9;
        }
        
        .feedback-strengths {
            margin-top: 12px;
            padding: 12px;
            background: linear-gradient(135deg, #f0fdf4, #ecfdf5);
            border-radius: 8px;
            border-left: 4px solid #22c55e;
        }
        
        .feedback-improvements {
            margin-top: 12px;
            padding: 12px;
            background: linear-gradient(135deg, #fffbeb, #fef3c7);
            border-radius: 8px;
            border-left: 4px solid #f59e0b;
        }
        
        .grading-info {
            margin-top: 10px;
            text-align: right;
            opacity: 0.7;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        .api-key-input {
            margin-bottom: 20px;
            padding: 20px;
            background: #f0f4f8;
            border-radius: 10px;
        }

        .api-key-input input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .card {
                padding: 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“š ì‹œí—˜ ë¬¸ì œ ì—°ìŠµ ì„œë¹„ìŠ¤</h1>
            <p>ë‹¤ì–‘í•œ ìœ í˜•ì˜ ë¬¸ì œë¥¼ í’€ê³  ì‹¤ë ¥ì„ í–¥ìƒì‹œì¼œë³´ì„¸ìš”!</p>
        </div>

        <!-- ì „ì—­ ë¹„ë°€ë²ˆí˜¸ ë³´í˜¸ í™”ë©´ -->
        <div class="card" id="globalPasswordSection">
            <div style="text-align: center; padding: 40px 20px;">
                <h2>ğŸ” ì„œë¹„ìŠ¤ ì ‘ì†</h2>
                <p style="margin: 20px 0; color: #718096;">ì´ ì„œë¹„ìŠ¤ëŠ” ë¹„ë°€ë²ˆí˜¸ë¡œ ë³´í˜¸ë˜ê³  ìˆìŠµë‹ˆë‹¤.</p>
                <div style="max-width: 300px; margin: 0 auto;">
                    <input type="password" id="globalPasswordInput" placeholder="ì ‘ì† ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”" 
                           style="width: 100%; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; margin-bottom: 15px; text-align: center;">
                    <button class="btn" onclick="checkGlobalPassword()" style="width: 100%;">ğŸš€ ì ‘ì†í•˜ê¸°</button>
                    <div id="globalPasswordError" style="color: #e53e3e; margin-top: 10px; font-size: 0.9rem; display: none;">
                        âŒ ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.
                    </div>
                </div>
            </div>
        </div>

        <!-- ë©”ì¸ ì„œë¹„ìŠ¤ ì»¨í…Œì´ë„ˆ (ë¹„ë°€ë²ˆí˜¸ í™•ì¸ í›„ í‘œì‹œ) -->
        <div id="mainServiceContainer" class="hidden">

        <!-- API Key ì„¤ì • -->
        <div class="card api-key-input" id="apiKeySection">
            <h3>ğŸ”‘ OpenAI API í‚¤ ì„¤ì •</h3>
            <p>ì£¼ê´€ì‹ ë¬¸ì œ ì±„ì ì„ ìœ„í•´ OpenAI API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.</p>
            <input type="password" id="apiKeyInput" placeholder="OpenAI API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”">
            <button class="btn" onclick="saveApiKey()">ì €ì¥</button>
            <button class="btn" onclick="showAdminLogin()" style="float: right; background: linear-gradient(145deg, #e53e3e, #c53030);">ğŸ”§ ê´€ë¦¬ì</button>
        </div>

        <!-- ê´€ë¦¬ì ë¡œê·¸ì¸ -->
        <div class="card hidden" id="adminLoginSection">
            <h3>ğŸ” ê´€ë¦¬ì ë¡œê·¸ì¸</h3>
            <p>ë¬¸ì œì§‘ ê´€ë¦¬ë¥¼ ìœ„í•´ ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</p>
            <input type="password" id="adminPasswordInput" placeholder="ê´€ë¦¬ì ë¹„ë°€ë²ˆí˜¸">
            <button class="btn" onclick="adminLogin()">ë¡œê·¸ì¸</button>
            <button class="btn" onclick="hideAdminLogin()" style="background: #718096;">ì·¨ì†Œ</button>
        </div>

        <!-- ê´€ë¦¬ì íŒ¨ë„ -->
        <div class="card hidden" id="adminPanel">
            <h2>ğŸ› ï¸ ê´€ë¦¬ì íŒ¨ë„</h2>
            <div style="margin-bottom: 20px;">
                <button class="btn" onclick="showAddProblemSet()">â• ë¬¸ì œì§‘ ì¶”ê°€</button>
                <button class="btn" onclick="hideAdminPanel()" style="background: #718096;">ë‚˜ê°€ê¸°</button>
            </div>
            
            <!-- ë¬¸ì œì§‘ ëª©ë¡ -->
            <div id="adminProblemSetsList">
                <h3>ğŸ“š ì €ì¥ëœ ë¬¸ì œì§‘</h3>
                <div id="problemSetsManagement"></div>
            </div>
        </div>

        <!-- ë¬¸ì œì§‘ ì¶”ê°€/í¸ì§‘ í¼ -->
        <div class="card hidden" id="addProblemSetForm">
            <h3 id="formTitle">â• ìƒˆ ë¬¸ì œì§‘ ì¶”ê°€</h3>
            <div style="margin-bottom: 15px;">
                <label for="problemSetKey">ë¬¸ì œì§‘ í‚¤ (ì˜ë¬¸, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´ë§Œ):</label>
                <input type="text" id="problemSetKey" placeholder="ì˜ˆ: custom_math_1" style="width: 100%; padding: 10px; margin-top: 5px; border: 2px solid #e2e8f0; border-radius: 8px;">
            </div>
            <div style="margin-bottom: 15px;">
                <label for="problemSetJSON">JSON ë°ì´í„°:</label>
                <textarea id="problemSetJSON" rows="20" placeholder='JSON í˜•ì‹ìœ¼ë¡œ ë¬¸ì œì§‘ì„ ì…ë ¥í•˜ì„¸ìš”...' style="width: 100%; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; font-family: monospace; font-size: 0.9rem;"></textarea>
            </div>
            <div>
                <button class="btn" onclick="saveProblemSet()" id="saveBtn">ì €ì¥</button>
                <button class="btn" onclick="hideAddProblemSetForm()" style="background: #718096;">ì·¨ì†Œ</button>
                <button class="btn" onclick="showJSONExample()" style="background: #38a169;">ğŸ“„ ì˜ˆì‹œ ë³´ê¸°</button>
            </div>
        </div>

        <!-- ì‹œí—˜ ì„ íƒ í™”ë©´ -->
        <div class="card exam-selector" id="examSelector">
            <h2>ğŸ“‹ ì‹œí—˜ ì„ íƒ</h2>
            <div class="exam-grid" id="examGrid">
                <!-- ì‹œí—˜ ëª©ë¡ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
            </div>
        </div>

        <!-- ë¬¸ì œ í’€ì´ í™”ë©´ -->
        <div class="card hidden" id="examContainer">
            <div id="examHeader">
                <h2 id="examTitle"></h2>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p>ë¬¸ì œ <span id="currentQuestion">1</span> / <span id="totalQuestions">10</span></p>
            </div>
            
            <div id="questionContainer">
                <!-- ë¬¸ì œë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="submitAnswers()" id="submitBtn">ë‹µì•ˆ ì œì¶œ</button>
                <button class="btn" onclick="resetExam()">ì²˜ìŒìœ¼ë¡œ</button>
            </div>
        </div>

        <!-- ê²°ê³¼ í™”ë©´ -->
        <div class="card hidden" id="resultsContainer">
            <div class="score-display" id="scoreDisplay">
                <h2 id="finalScore"></h2>
                <p id="scoreDescription"></p>
            </div>
            
            <div id="answerReviews">
                <!-- ë‹µì•ˆ ê²€í† ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="resetExam()">ë‹¤ì‹œ ì‹œì‘</button>
            </div>
        </div>

        </div> <!-- End of mainServiceContainer -->
    </div>

    <script>
        // API ì„¤ì •
        const API_BASE_URL = window.location.hostname === 'localhost' ? '' : '';
        
        // ë¬¸ì œì§‘ ë°ì´í„° ì €ì¥ì†Œ
        let examData = {};
        let problemSetsIndex = null;

        let currentExam = null;
        let userAnswers = {};
        let apiKey = '';
        let isAdminLoggedIn = false;
        let editingProblemSetKey = null;
        let ADMIN_PASSWORD = 'admin123'; // ê¸°ë³¸ê°’, í™˜ê²½ë³€ìˆ˜ë¡œ ë®ì–´ì“°ê¸° ê°€ëŠ¥
        let GLOBAL_PASSWORD = ''; // ì „ì—­ ì ‘ì† ë¹„ë°€ë²ˆí˜¸
        let isGloballyAuthenticated = false;
        let authToken = null; // API ì¸ì¦ í† í°
        let shuffledOptionsMap = {}; // ì„ì¸ ì„ íƒì§€ì˜ ë§¤í•‘ì„ ì €ì¥
        let currentRoute = null; // í˜„ì¬ ë¼ìš°íŠ¸ ì •ë³´ ì €ì¥
        
        // í† í° ì €ì¥ ë° ë¡œë“œ í•¨ìˆ˜
        function saveAuthToken(token) {
            localStorage.setItem('show-exam-auth-token', token);
            authToken = token;
        }
        
        function loadAuthToken() {
            const token = localStorage.getItem('show-exam-auth-token');
            if (token) {
                authToken = token;
                return token;
            }
            return null;
        }
        
        function clearAuthToken() {
            localStorage.removeItem('show-exam-auth-token');
            authToken = null;
        }
        
        // ì „ì—­ ë¹„ë°€ë²ˆí˜¸ í™•ì¸ í•¨ìˆ˜
        async function checkGlobalPassword() {
            const inputPassword = document.getElementById('globalPasswordInput').value.trim();
            const errorDiv = document.getElementById('globalPasswordError');
            
            if (!inputPassword) {
                showPasswordError('ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                // ì„œë²„ì—ì„œ ì¸ì¦ ì‹œë„
                const authResult = await apiCall('auth', {
                    method: 'POST',
                    body: JSON.stringify({ password: inputPassword })
                });

                if (authResult.success) {
                    saveAuthToken(authResult.token);
                    isGloballyAuthenticated = true;
                    
                    // ì¸ì¦ ì„±ê³µ ì‹œ ë©”ì¸ ì„œë¹„ìŠ¤ ë¡œë“œ
                    await initializeMainService();
                    
                    // UI ì „í™˜
                    document.getElementById('globalPasswordSection').classList.add('hidden');
                    document.getElementById('mainServiceContainer').classList.remove('hidden');
                    
                    // ë¼ìš°íŒ… ì´ˆê¸°í™” (UI ì „í™˜ í›„)
                    initializeRouting();
                    
                    // ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ì°½ ì´ˆê¸°í™”
                    document.getElementById('globalPasswordInput').value = '';
                    errorDiv.style.display = 'none';
                    
                } else {
                    showPasswordError('ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('Authentication failed:', error);
                showPasswordError('ì¸ì¦ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        function showPasswordError(message) {
            const errorDiv = document.getElementById('globalPasswordError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            // 3ì´ˆ í›„ ì—ëŸ¬ ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 3000);
        }

        // ë©”ì¸ ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        async function initializeMainService() {
            await loadEnvironmentVariables();
            updateApiKeyUI();
            await loadProblemSetsIndex();
            await loadExamList();
            renderMath();
        }

        // í™˜ê²½ë³€ìˆ˜ ë¡œë“œ í•¨ìˆ˜
        async function loadEnvironmentVariables() {
            try {
                // ì„œë²„ì—ì„œ í™˜ê²½ë³€ìˆ˜ ë¡œë“œ (ì¸ì¦ í† í° í¬í•¨)
                const config = await apiCall('config', {
                    headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {}
                });
                
                if (config.openaiApiKey) {
                    apiKey = config.openaiApiKey;
                    console.log('OpenAI API Key loaded from server environment variables');
                }
                
                if (config.adminPassword) {
                    ADMIN_PASSWORD = config.adminPassword;
                }
                
                if (config.globalPassword) {
                    GLOBAL_PASSWORD = config.globalPassword;
                }
                
            } catch (error) {
                console.error('Failed to load server configuration:', error);
                // Fallback to localStorage
                apiKey = localStorage.getItem('openai_api_key') || '';
            }
            
            // localStorageì—ì„œ ì‚¬ìš©ìê°€ ì…ë ¥í•œ í‚¤ê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©
            const storedApiKey = localStorage.getItem('openai_api_key');
            if (storedApiKey) {
                apiKey = storedApiKey;
                console.log('Using API key from localStorage (user override)');
            }
        }
        

        // ë°°ì—´ ì„ê¸° í•¨ìˆ˜ (Fisher-Yates shuffle)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // ì„ íƒì§€ ì„ê¸° ë° ë§¤í•‘ ìƒì„±
        function shuffleOptionsWithMapping(options, questionId) {
            const indexedOptions = options.map((option, index) => ({ option, originalIndex: index }));
            const shuffled = shuffleArray(indexedOptions);
            
            // ì›ë³¸ ì¸ë±ìŠ¤ -> ì„ì¸ ì¸ë±ìŠ¤ ë§¤í•‘
            const originalToShuffled = {};
            // ì„ì¸ ì¸ë±ìŠ¤ -> ì›ë³¸ ì¸ë±ìŠ¤ ë§¤í•‘
            const shuffledToOriginal = {};
            
            shuffled.forEach((item, newIndex) => {
                originalToShuffled[item.originalIndex] = newIndex;
                shuffledToOriginal[newIndex] = item.originalIndex;
            });
            
            shuffledOptionsMap[questionId] = {
                originalToShuffled,
                shuffledToOriginal,
                shuffledOptions: shuffled.map(item => item.option)
            };
            
            return shuffled.map(item => item.option);
        }

        // API í•¨ìˆ˜ë“¤
        async function apiCall(endpoint, options = {}) {
            try {
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                // ì¸ì¦ëœ ê²½ìš° í† í° ì¶”ê°€ (auth ì—”ë“œí¬ì¸íŠ¸ ì œì™¸)
                if (authToken && endpoint !== 'auth') {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE_URL}/api/${endpoint}`, {
                    headers,
                    ...options
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    
                    // 401 Unauthorized - í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŒ
                    if (response.status === 401 && authToken) {
                        clearAuthToken();
                        isGloballyAuthenticated = false;
                        // ë¡œê·¸ì¸ í™”ë©´ìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
                        document.getElementById('globalPasswordSection').classList.remove('hidden');
                        document.getElementById('mainServiceContainer').classList.add('hidden');
                    }
                    
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        async function loadProblemSetsIndex() {
            try {
                if (!authToken) {
                    console.error('No auth token available for API call');
                    return loadFallbackData();
                }
                
                problemSetsIndex = await apiCall('problem-sets');
                console.log('Problem sets index loaded successfully:', problemSetsIndex);
                return problemSetsIndex;
            } catch (error) {
                console.error('Failed to load problem sets index:', error);
                // Fallback to built-in data
                return loadFallbackData();
            }
        }

        async function loadProblemSet(key) {
            try {
                const problemSet = await apiCall(`problem-sets?key=${key}`);
                examData[key] = problemSet;
                return problemSet;
            } catch (error) {
                console.error(`Failed to load problem set ${key}:`, error);
                return null;
            }
        }

        async function saveProblemSetToAPI(key, data) {
            try {
                await apiCall('problem-sets', {
                    method: 'POST',
                    body: JSON.stringify({ key, data })
                });
                return true;
            } catch (error) {
                console.error('Failed to save problem set:', error);
                throw error;
            }
        }

        async function updateProblemSetInAPI(key, data) {
            try {
                await apiCall(`problem-sets?key=${key}`, {
                    method: 'PUT',
                    body: JSON.stringify({ data })
                });
                return true;
            } catch (error) {
                console.error('Failed to update problem set:', error);
                throw error;
            }
        }

        async function deleteProblemSetFromAPI(key) {
            try {
                await apiCall(`problem-sets?key=${key}`, {
                    method: 'DELETE'
                });
                return true;
            } catch (error) {
                console.error('Failed to delete problem set:', error);
                throw error;
            }
        }

        // Fallback ë°ì´í„° (API ì‹¤íŒ¨ ì‹œ ì‚¬ìš©)
        function loadFallbackData() {
            console.log('Using fallback data due to API failure');
            
            // ê¸°ë³¸ ë¬¸ì œì§‘ ë°ì´í„°ë¥¼ ì§ì ‘ ë¡œë“œ
            const fallbackMathData = {
                "title": "ê¸°ì´ˆ ìˆ˜í•™",
                "description": "ê¸°ë³¸ì ì¸ ìˆ˜í•™ ê°œë…ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œë“¤",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "ë‹¤ìŒ ì¤‘ $\\sqrt{16}$ì˜ ê°’ì€?",
                        "options": ["2", "4", "8", "16"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "$\\sqrt{16} = 4$ì…ë‹ˆë‹¤. 16ì˜ ì œê³±ê·¼ì€ 4ì…ë‹ˆë‹¤."
                    },
                    {
                        "id": 2,
                        "type": "multiple_choice",
                        "question": "ë‹¤ìŒ ì¤‘ ì†Œìˆ˜ì¸ ê²ƒì„ ëª¨ë‘ ê³ ë¥´ì„¸ìš”.",
                        "options": ["2", "3", "4", "5", "6", "7"],
                        "correct_answers": [0, 1, 3, 5],
                        "score": 15,
                        "explanation": "ì†Œìˆ˜ëŠ” 1ê³¼ ìê¸° ìì‹ ìœ¼ë¡œë§Œ ë‚˜ëˆ„ì–´ì§€ëŠ” ìì—°ìˆ˜ì…ë‹ˆë‹¤. 2, 3, 5, 7ì´ ì†Œìˆ˜ì…ë‹ˆë‹¤."
                    },
                    {
                        "id": 3,
                        "type": "true_false",
                        "question": "$\\pi$ëŠ” ë¬´ë¦¬ìˆ˜ì´ë‹¤.",
                        "correct_answer": true,
                        "score": 10,
                        "explanation": "$\\pi$ëŠ” ë¬´ë¦¬ìˆ˜ì…ë‹ˆë‹¤. ìœ í•œì†Œìˆ˜ë‚˜ ìˆœí™˜ì†Œìˆ˜ë¡œ í‘œí˜„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
                    }
                ]
            };
            
            const fallbackPhysicsData = {
                "title": "ê¸°ì´ˆ ë¬¼ë¦¬í•™",
                "description": "ë¬¼ë¦¬í•™ì˜ ê¸°ë³¸ ê°œë…ê³¼ ê³µì‹ë“¤",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "ììœ ë‚™í•˜í•˜ëŠ” ë¬¼ì²´ì˜ ê°€ì†ë„ëŠ” ëŒ€ëµ ì–¼ë§ˆì¸ê°€?",
                        "options": ["$9.8 \\text{ m/s}$", "$9.8 \\text{ m/s}^2$", "$98 \\text{ m/s}^2$", "$0.98 \\text{ m/s}^2$"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "ì§€êµ¬ì—ì„œ ì¤‘ë ¥ê°€ì†ë„ëŠ” ì•½ $9.8 \\text{ m/s}^2$ì…ë‹ˆë‹¤."
                    }
                ]
            };
            
            // examDataì— fallback ë°ì´í„° ë¡œë“œ
            examData['math_basic'] = fallbackMathData;
            examData['physics_basic'] = fallbackPhysicsData;
            
            return {
                version: "1.0.0",
                problem_sets: [
                    {
                        key: "math_basic",
                        title: "ê¸°ì´ˆ ìˆ˜í•™",
                        description: "ê¸°ë³¸ì ì¸ ìˆ˜í•™ ê°œë…ì„ ë‹¤ë£¨ëŠ” ë¬¸ì œë“¤",
                        category: "mathematics",
                        is_built_in: true
                    },
                    {
                        key: "physics_basic",
                        title: "ê¸°ì´ˆ ë¬¼ë¦¬í•™", 
                        description: "ë¬¼ë¦¬í•™ì˜ ê¸°ë³¸ ê°œë…ê³¼ ê³µì‹ë“¤",
                        category: "physics",
                        is_built_in: true
                    }
                ]
            };
        }

        // ë¼ìš°íŒ… ì‹œìŠ¤í…œ
        function initializeRouting() {
            // í˜ì´ì§€ ë¡œë“œ ì‹œ URL í™•ì¸
            handleRouteChange();
            
            // ë¸Œë¼ìš°ì € ë’¤ë¡œê°€ê¸°/ì•ìœ¼ë¡œê°€ê¸° ì²˜ë¦¬
            window.addEventListener('popstate', handleRouteChange);
        }

        function handleRouteChange() {
            const path = window.location.pathname;
            const hash = window.location.hash;
            
            // URL íŒ¨í„´: /problem/{problemSetKey}/{questionId}
            const problemMatch = path.match(/^\/problem\/([^\/]+)\/(\d+)$/);
            
            if (problemMatch) {
                const [, problemSetKey, questionId] = problemMatch;
                currentRoute = {
                    type: 'problem',
                    problemSetKey,
                    questionId: parseInt(questionId)
                };
                
                // ì¸ì¦ëœ ìƒíƒœì—ì„œë§Œ ë¬¸ì œ í‘œì‹œ
                if (isGloballyAuthenticated) {
                    showSpecificProblem(problemSetKey, parseInt(questionId));
                }
            } else if (hash.startsWith('#/problem/')) {
                // Hash ê¸°ë°˜ ë¼ìš°íŒ… ì§€ì› (fallback)
                const hashMatch = hash.match(/^#\/problem\/([^\/]+)\/(\d+)$/);
                if (hashMatch) {
                    const [, problemSetKey, questionId] = hashMatch;
                    currentRoute = {
                        type: 'problem',
                        problemSetKey,
                        questionId: parseInt(questionId)
                    };
                    
                    if (isGloballyAuthenticated) {
                        showSpecificProblem(problemSetKey, parseInt(questionId));
                    }
                }
            } else {
                // URL íŒ¨í„´: /exam/{problemSetKey}
                const examMatch = path.match(/^\/exam\/([^\/]+)$/);
                
                if (examMatch) {
                    const [, problemSetKey] = examMatch;
                    currentRoute = {
                        type: 'exam',
                        problemSetKey
                    };
                    
                    // ì¸ì¦ëœ ìƒíƒœì—ì„œë§Œ ì‹œí—˜ ì‹œì‘
                    if (isGloballyAuthenticated) {
                        startExam(problemSetKey);
                    }
                } else {
                    currentRoute = { type: 'home' };
                    if (isGloballyAuthenticated) {
                        showHome();
                    }
                }
            }
        }

        function navigateToProblem(problemSetKey, questionId) {
            const url = `/problem/${problemSetKey}/${questionId}`;
            history.pushState(null, '', url);
            currentRoute = {
                type: 'problem',
                problemSetKey,
                questionId
            };
            showSpecificProblem(problemSetKey, questionId);
        }

        function navigateToHome() {
            history.pushState(null, '', '/');
            currentRoute = { type: 'home' };
            showHome();
        }

        function showHome() {
            document.getElementById('examSelector').classList.remove('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            document.getElementById('singleProblemContainer').classList.add('hidden');
            const problemListContainer = document.getElementById('problemListContainer');
            if (problemListContainer) {
                problemListContainer.classList.add('hidden');
            }
        }

        async function showSpecificProblem(problemSetKey, questionId) {
            // ë¬¸ì œì§‘ ë¡œë“œ
            if (!examData[problemSetKey]) {
                await loadProblemSet(problemSetKey);
            }
            
            const problemSet = examData[problemSetKey];
            if (!problemSet) {
                alert('ë¬¸ì œì§‘ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                navigateToHome();
                return;
            }

            // ë¬¸ì œ ì°¾ê¸°
            let targetQuestion = null;
            let questionNumber = 1;
            
            for (const question of problemSet.questions) {
                if (question.type === 'compound') {
                    for (let subIndex = 0; subIndex < question.sub_questions.length; subIndex++) {
                        if (question.id === questionId && subIndex === 0) {
                            // ë³µí•© ë¬¸ì œì˜ ê²½ìš° ì „ì²´ ë¬¸ì œ í‘œì‹œ
                            targetQuestion = question;
                            break;
                        }
                        questionNumber++;
                    }
                } else {
                    if (question.id === questionId) {
                        targetQuestion = question;
                        break;
                    }
                    questionNumber++;
                }
                if (targetQuestion) break;
            }

            if (!targetQuestion) {
                alert('ë¬¸ì œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                navigateToHome();
                return;
            }

            // ë‹¨ì¼ ë¬¸ì œ í‘œì‹œ
            renderSingleProblemView(problemSet, targetQuestion, questionNumber);
        }

        function renderSingleProblemView(problemSet, question, questionNumber) {
            // ê¸°ì¡´ í™”ë©´ ìˆ¨ê¸°ê¸°
            document.getElementById('examSelector').classList.add('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            
            // ë‹¨ì¼ ë¬¸ì œ ì»¨í…Œì´ë„ˆ í‘œì‹œ
            let singleContainer = document.getElementById('singleProblemContainer');
            if (!singleContainer) {
                singleContainer = document.createElement('div');
                singleContainer.id = 'singleProblemContainer';
                singleContainer.className = 'card hidden';
                document.querySelector('.container').appendChild(singleContainer);
            }
            
            singleContainer.classList.remove('hidden');
            
            // í—¤ë” ìƒì„±
            const header = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <div>
                        <h2>${problemSet.title}</h2>
                        <p>ë¬¸ì œ ${questionNumber}</p>
                    </div>
                    <div>
                        <button class="btn" onclick="navigateToHome()" style="background: #718096;">ëª©ë¡ìœ¼ë¡œ</button>
                        <button class="btn" onclick="startExam('${currentRoute.problemSetKey}')" style="background: #38a169;">ì „ì²´ ì‹œí—˜</button>
                    </div>
                </div>
            `;
            
            // ë¬¸ì œ ë Œë”ë§
            let questionHtml = '';
            if (question.type === 'compound') {
                questionHtml = `
                    <div class="question-container">
                        <div class="question-header">
                            <span class="question-number">${questionNumber}</span>
                            <span class="question-score">${question.score}ì </span>
                        </div>
                        <div class="question-text">${question.question}</div>
                        <div class="sub-questions">
                            ${question.sub_questions.map((subQ, subIndex) => {
                                const subQuestionHtml = renderSubQuestion(subQ, `${question.id}-${subIndex}`, questionNumber + subIndex);
                                return `<div class="sub-question">${subQuestionHtml}</div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            } else {
                questionHtml = `
                    <div class="question-container">
                        ${renderSingleQuestion(question, questionNumber)}
                    </div>
                `;
            }
            
            singleContainer.innerHTML = `
                ${header}
                ${questionHtml}
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn" onclick="submitSingleProblem()">ë‹µì•ˆ í™•ì¸</button>
                </div>
                <div id="singleProblemResult" class="hidden" style="margin-top: 30px;"></div>
            `;
            
            setTimeout(renderMath, 100);
        }

        async function submitSingleProblem() {
            const question = getCurrentQuestion();
            if (!question) return;
            
            // ë‹µì•ˆ ìˆ˜ì§‘
            let userAnswer;
            const questionId = question.type === 'compound' ? `${question.id}-0` : question.id;
            
            if (question.type === 'compound') {
                // ë³µí•© ë¬¸ì œì˜ ê²½ìš° ëª¨ë“  í•˜ìœ„ ë¬¸ì œ ë‹µì•ˆ ìˆ˜ì§‘
                const subAnswers = {};
                question.sub_questions.forEach((subQ, subIndex) => {
                    const subQuestionId = `${question.id}-${subIndex}`;
                    subAnswers[subQuestionId] = collectSingleAnswer(subQ, subQuestionId);
                });
                userAnswer = subAnswers;
            } else {
                userAnswer = collectSingleAnswer(question, questionId);
            }
            
            // ì±„ì  ìˆ˜í–‰
            let results = {};
            if (question.type === 'compound') {
                for (let subIndex = 0; subIndex < question.sub_questions.length; subIndex++) {
                    const subQ = question.sub_questions[subIndex];
                    const subQuestionId = `${question.id}-${subIndex}`;
                    const subAnswer = userAnswer[subQuestionId];
                    
                    if (subQ.type === 'essay') {
                        results[subQuestionId] = await gradeEssayWithAPI(subQ, subAnswer);
                    } else {
                        results[subQuestionId] = gradeObjectiveQuestion(subQ, subAnswer);
                    }
                }
            } else {
                if (question.type === 'essay') {
                    results[questionId] = await gradeEssayWithAPI(question, userAnswer);
                } else {
                    results[questionId] = gradeObjectiveQuestion(question, userAnswer);
                }
            }
            
            // ê²°ê³¼ í‘œì‹œ
            showSingleProblemResult(question, results);
        }

        function getCurrentQuestion() {
            if (!currentRoute || !currentRoute.problemSetKey || !currentRoute.questionId) return null;
            
            const problemSet = examData[currentRoute.problemSetKey];
            if (!problemSet) return null;
            
            return problemSet.questions.find(q => q.id === currentRoute.questionId);
        }

        function showSingleProblemResult(question, results) {
            const resultContainer = document.getElementById('singleProblemResult');
            resultContainer.classList.remove('hidden');
            
            let totalScore = 0;
            let maxTotalScore = 0;
            
            // ì ìˆ˜ ê³„ì‚°
            for (const result of Object.values(results)) {
                totalScore += result.score;
                maxTotalScore += result.maxScore;
            }
            
            // ê²°ê³¼ HTML ìƒì„±
            let resultHtml = `
                <div class="score-display">
                    <h3>ê²°ê³¼: ${totalScore}/${maxTotalScore}ì </h3>
                </div>
            `;
            
            if (question.type === 'compound') {
                question.sub_questions.forEach((subQ, subIndex) => {
                    const questionId = `${question.id}-${subIndex}`;
                    const result = results[questionId];
                    const reviewDiv = createAnswerReview(subQ, result, subIndex + 1);
                    resultHtml += reviewDiv.outerHTML;
                });
            } else {
                const result = results[question.id];
                const reviewDiv = createAnswerReview(question, result, 1);
                resultHtml += reviewDiv.outerHTML;
            }
            
            resultContainer.innerHTML = resultHtml;
            setTimeout(renderMath, 100);
        }

        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', async function() {
            // ì €ì¥ëœ í† í°ì´ ìˆëŠ”ì§€ í™•ì¸
            const savedToken = loadAuthToken();
            if (savedToken) {
                try {
                    // í† í° ìœ íš¨ì„± í™•ì¸ì„ ìœ„í•´ API í˜¸ì¶œ ì‹œë„
                    const testResult = await apiCall('problem-sets');
                    if (testResult && !testResult.error) {
                        // í† í°ì´ ìœ íš¨í•˜ë©´ ë©”ì¸ ì„œë¹„ìŠ¤ ë¡œë“œ
                        isGloballyAuthenticated = true;
                        await initializeMainService();
                        initializeRouting(); // ë¼ìš°íŒ… ì´ˆê¸°í™”
                        document.getElementById('globalPasswordSection').classList.add('hidden');
                        document.getElementById('mainServiceContainer').classList.remove('hidden');
                        return; // ì¸ì¦ ì„±ê³µ ì‹œ ì—¬ê¸°ì„œ ì¢…ë£Œ
                    }
                } catch (error) {
                    console.log('Saved token is invalid, clearing...');
                }
                // í† í°ì´ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì œê±°
                clearAuthToken();
            }
            
            // ì „ì—­ ë¹„ë°€ë²ˆí˜¸ ë³´í˜¸ê°€ í™œì„±í™”ëœ ê²½ìš° ë¡œê·¸ì¸ í™”ë©´ í‘œì‹œ
            // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ë°”ë¡œ ë©”ì¸ ì„œë¹„ìŠ¤ ë¡œë“œ (í•„ìš”ì‹œ ì£¼ì„ í•´ì œ)
            // if (window.location.hostname === 'localhost') {
            //     await initializeMainService();
            //     document.getElementById('globalPasswordSection').classList.add('hidden');
            //     document.getElementById('mainServiceContainer').classList.remove('hidden');
            // }
            
            // Enter í‚¤ ì§€ì›
            document.getElementById('globalPasswordInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    checkGlobalPassword();
                }
            });
        });
        
        // API í‚¤ UI ì—…ë°ì´íŠ¸
        function updateApiKeyUI() {
            const apiKeyInput = document.getElementById('apiKeyInput');
            const apiKeySection = document.getElementById('apiKeySection');
            
            if (apiKey) {
                apiKeyInput.value = '***APIí‚¤ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤***';
                apiKeyInput.disabled = true;
                
                // í™˜ê²½ë³€ìˆ˜ì—ì„œ ë¡œë“œëœ ê²½ìš° ì•Œë¦¼ í‘œì‹œ
                const envSource = document.createElement('p');
                envSource.style.cssText = 'color: #38a169; font-size: 0.9rem; margin-top: 5px;';
                envSource.innerHTML = 'âœ… API í‚¤ê°€ í™˜ê²½ë³€ìˆ˜ì—ì„œ ìë™ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.';
                
                if (!document.querySelector('.env-source-notice')) {
                    envSource.className = 'env-source-notice';
                    apiKeySection.appendChild(envSource);
                }
            } else {
                // í™˜ê²½ë³€ìˆ˜ì—ì„œ ë¡œë“œë˜ì§€ ì•Šì€ ê²½ìš° ì‚¬ìš©ì ì…ë ¥ í—ˆìš©
                const notice = document.createElement('p');
                notice.style.cssText = 'color: #e53e3e; font-size: 0.9rem; margin-top: 5px;';
                notice.innerHTML = 'âš ï¸ í™˜ê²½ë³€ìˆ˜ì—ì„œ API í‚¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì§ì ‘ ì…ë ¥í•´ì£¼ì„¸ìš”.';
                notice.className = 'env-source-notice';
                apiKeySection.appendChild(notice);
            }
        }

        function renderMath() {
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ]
                });
            }
        }

        function saveApiKey() {
            const inputElement = document.getElementById('apiKeyInput');
            const key = inputElement.value.trim();
            
            // í™˜ê²½ë³€ìˆ˜ë¡œ ì´ë¯¸ ì„¤ì •ëœ ê²½ìš° ì‚¬ìš©ì ì…ë ¥ ë¬´ì‹œ
            if (inputElement.disabled) {
                alert('API í‚¤ê°€ ì´ë¯¸ í™˜ê²½ë³€ìˆ˜ì—ì„œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
                return;
            }
            
            if (key && key !== '***APIí‚¤ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤***') {
                apiKey = key;
                localStorage.setItem('openai_api_key', key);
                updateApiKeyUI();
                alert('API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else {
                alert('ìœ íš¨í•œ API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            }
        }

        // ê´€ë¦¬ì ê¸°ëŠ¥
        function showAdminLogin() {
            document.getElementById('adminLoginSection').classList.remove('hidden');
        }

        function hideAdminLogin() {
            document.getElementById('adminLoginSection').classList.add('hidden');
            document.getElementById('adminPasswordInput').value = '';
        }

        function adminLogin() {
            const password = document.getElementById('adminPasswordInput').value;
            if (password === ADMIN_PASSWORD) {
                isAdminLoggedIn = true;
                hideAdminLogin();
                showAdminPanel();
                loadProblemSetsManagement();
            } else {
                alert('ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.');
            }
        }

        function showAdminPanel() {
            document.getElementById('adminPanel').classList.remove('hidden');
        }

        function hideAdminPanel() {
            document.getElementById('adminPanel').classList.add('hidden');
            isAdminLoggedIn = false;
        }

        function showAddProblemSet() {
            editingProblemSetKey = null;
            document.getElementById('formTitle').textContent = 'â• ìƒˆ ë¬¸ì œì§‘ ì¶”ê°€';
            document.getElementById('problemSetKey').value = '';
            document.getElementById('problemSetJSON').value = '';
            document.getElementById('saveBtn').textContent = 'ì €ì¥';
            document.getElementById('addProblemSetForm').classList.remove('hidden');
        }

        function hideAddProblemSetForm() {
            document.getElementById('addProblemSetForm').classList.add('hidden');
            editingProblemSetKey = null;
        }

        function showJSONExample() {
            const example = {
                "title": "ì˜ˆì‹œ ë¬¸ì œì§‘",
                "description": "JSON í˜•ì‹ì˜ ì˜ˆì‹œ ë¬¸ì œì§‘ì…ë‹ˆë‹¤",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "2 + 2 = ?",
                        "options": ["3", "4", "5", "6"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "2 + 2 = 4ì…ë‹ˆë‹¤."
                    }
                ]
            };
            document.getElementById('problemSetJSON').value = JSON.stringify(example, null, 2);
        }

        async function saveProblemSet() {
            const key = document.getElementById('problemSetKey').value.trim();
            const jsonText = document.getElementById('problemSetJSON').value.trim();

            if (!key) {
                alert('ë¬¸ì œì§‘ í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(key)) {
                alert('ë¬¸ì œì§‘ í‚¤ëŠ” ì˜ë¬¸, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                return;
            }

            if (!jsonText) {
                alert('JSON ë°ì´í„°ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const problemSet = JSON.parse(jsonText);
                
                // ê¸°ë³¸ êµ¬ì¡° ê²€ì¦
                if (!problemSet.title || !problemSet.description || !problemSet.questions) {
                    alert('JSON í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. title, description, questions í•„ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤.');
                    return;
                }

                // APIì— ì €ì¥
                if (editingProblemSetKey) {
                    // í¸ì§‘ ëª¨ë“œ
                    await updateProblemSetInAPI(key, problemSet);
                    examData[key] = problemSet; // ë¡œì»¬ ìºì‹œ ì—…ë°ì´íŠ¸
                } else {
                    // ìƒˆë¡œ ìƒì„±
                    await saveProblemSetToAPI(key, problemSet);
                    examData[key] = problemSet; // ë¡œì»¬ ìºì‹œì— ì¶”ê°€
                }

                alert('ë¬¸ì œì§‘ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
                hideAddProblemSetForm();
                await loadProblemSetsIndex(); // ì¸ë±ìŠ¤ ìƒˆë¡œê³ ì¹¨
                await loadProblemSetsManagement();
                await loadExamList(); // ì‹œí—˜ ëª©ë¡ ìƒˆë¡œê³ ì¹¨

            } catch (error) {
                if (error.message.includes('already exists')) {
                    alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë¬¸ì œì§‘ í‚¤ì…ë‹ˆë‹¤.');
                } else {
                    alert('ë¬¸ì œì§‘ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }
        }

        function getCustomProblemSets() {
            // For backward compatibility, check localStorage
            const stored = localStorage.getItem('custom_problem_sets');
            return stored ? JSON.parse(stored) : {};
        }

        function getAllProblemSets() {
            return examData;
        }

        function editProblemSet(key) {
            const allSets = getAllProblemSets();
            const problemSet = allSets[key];
            
            if (!problemSet) {
                alert('ë¬¸ì œì§‘ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            editingProblemSetKey = key;
            document.getElementById('formTitle').textContent = 'âœï¸ ë¬¸ì œì§‘ í¸ì§‘';
            document.getElementById('problemSetKey').value = key;
            document.getElementById('problemSetJSON').value = JSON.stringify(problemSet, null, 2);
            document.getElementById('saveBtn').textContent = 'ìˆ˜ì • ì €ì¥';
            document.getElementById('addProblemSetForm').classList.remove('hidden');
        }

        async function deleteProblemSet(key) {
            const problemSetInfo = problemSetsIndex.problem_sets.find(ps => ps.key === key);
            
            if (problemSetInfo && problemSetInfo.is_built_in) {
                alert('ê¸°ë³¸ ë¬¸ì œì§‘ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            if (confirm(`'${key}' ë¬¸ì œì§‘ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                try {
                    await deleteProblemSetFromAPI(key);
                    delete examData[key]; // ë¡œì»¬ ìºì‹œì—ì„œ ì œê±°
                    
                    await loadProblemSetsIndex(); // ì¸ë±ìŠ¤ ìƒˆë¡œê³ ì¹¨
                    await loadProblemSetsManagement();
                    await loadExamList(); // ì‹œí—˜ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    alert('ë¬¸ì œì§‘ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                } catch (error) {
                    alert('ë¬¸ì œì§‘ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            }
        }

        async function loadProblemSetsManagement() {
            const container = document.getElementById('problemSetsManagement');
            container.innerHTML = '';
            
            if (!problemSetsIndex) {
                container.innerHTML = '<p>ë¬¸ì œì§‘ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>';
                return;
            }
            
            for (const problemSetInfo of problemSetsIndex.problem_sets) {
                const key = problemSetInfo.key;
                const exam = examData[key];
                
                if (!exam) {
                    // ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì€ ë¬¸ì œì§‘ì€ ë¡œë“œ
                    await loadProblemSet(key);
                }
                
                const setDiv = document.createElement('div');
                setDiv.style.cssText = 'border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; margin: 10px 0; background: #f8fafc;';
                
                const questionCount = examData[key] ? getTotalQuestionCount(examData[key].questions) : '?';
                
                setDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4>${problemSetInfo.title} ${problemSetInfo.is_built_in ? '(ê¸°ë³¸)' : '(ì»¤ìŠ¤í…€)'}</h4>
                            <p style="color: #718096; margin: 5px 0;">${problemSetInfo.description}</p>
                            <small style="color: #a0aec0;">í‚¤: ${key} | ë¬¸ì œ ìˆ˜: ${questionCount}</small>
                        </div>
                        <div>
                            <button onclick="editProblemSet('${key}')" style="background: #4299e1; color: white; border: none; padding: 8px 12px; border-radius: 4px; margin: 0 5px; cursor: pointer;">í¸ì§‘</button>
                            ${!problemSetInfo.is_built_in ? `<button onclick="deleteProblemSet('${key}')" style="background: #e53e3e; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">ì‚­ì œ</button>` : ''}
                        </div>
                    </div>
                `;
                
                container.appendChild(setDiv);
            }
        }

        async function loadExamList() {
            const examGrid = document.getElementById('examGrid');
            examGrid.innerHTML = '';

            if (!problemSetsIndex || !problemSetsIndex.problem_sets) {
                console.log('Problem sets index not available, trying to reload...');
                
                // Try to reload the problem sets index
                try {
                    problemSetsIndex = await loadProblemSetsIndex();
                } catch (error) {
                    console.error('Failed to reload problem sets index:', error);
                    examGrid.innerHTML = '<p style="color: #e53e3e;">ë¬¸ì œì§‘ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨í•´ë³´ì„¸ìš”.</p>';
                    return;
                }
                
                if (!problemSetsIndex || !problemSetsIndex.problem_sets) {
                    examGrid.innerHTML = '<p style="color: #e53e3e;">ë¬¸ì œì§‘ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
                    return;
                }
            }

            console.log('Loading exam list with', problemSetsIndex.problem_sets.length, 'problem sets');

            for (const problemSetInfo of problemSetsIndex.problem_sets) {
                const key = problemSetInfo.key;
                
                const examCard = document.createElement('div');
                examCard.className = 'exam-card';
                examCard.onclick = () => startExam(key);
                
                // ë¬¸ì œ ê°œìˆ˜ ê³„ì‚°
                let questionCount = 0;
                if (examData[key]) {
                    questionCount = getTotalQuestionCount(examData[key].questions);
                }
                
                examCard.innerHTML = `
                    <h3>${problemSetInfo.title}</h3>
                    <p>${problemSetInfo.description}</p>
                    <p><strong>ì¹´í…Œê³ ë¦¬:</strong> ${problemSetInfo.category || 'general'}</p>
                    ${questionCount > 0 ? `<p><strong>ë¬¸ì œ ìˆ˜:</strong> ${questionCount}ê°œ</p>` : ''}
                    <div style="margin-top: 15px; text-align: right;">
                        <button onclick="showProblemList('${key}')" style="background: #4299e1; color: white; border: none; padding: 8px 12px; border-radius: 4px; font-size: 0.85rem; margin-right: 8px;">ğŸ“‹ ë¬¸ì œ ëª©ë¡</button>
                        <button onclick="copyProblemSetUrl('${key}'); event.stopPropagation();" style="background: #38a169; color: white; border: none; padding: 8px 12px; border-radius: 4px; font-size: 0.85rem;">ğŸ”— URL ë³µì‚¬</button>
                    </div>
                `;
                
                examGrid.appendChild(examCard);
            }
        }

        function getTotalQuestionCount(questions) {
            let count = 0;
            questions.forEach(q => {
                if (q.type === 'compound') {
                    count += q.sub_questions.length;
                } else {
                    count += 1;
                }
            });
            return count;
        }

        function copyProblemSetUrl(problemSetKey) {
            const baseUrl = window.location.origin;
            const problemSetUrl = `${baseUrl}/exam/${problemSetKey}`;
            
            navigator.clipboard.writeText(problemSetUrl).then(() => {
                // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
                const button = event.target;
                const originalText = button.innerHTML;
                button.innerHTML = 'âœ… ë³µì‚¬ë¨';
                button.style.background = '#38a169';
                
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.style.background = '#38a169';
                }, 2000);
            }).catch(err => {
                console.error('URL ë³µì‚¬ ì‹¤íŒ¨:', err);
                // í´ë°±: alertìœ¼ë¡œ URL í‘œì‹œ
                alert(`ë¬¸ì œì§‘ URL:\n${problemSetUrl}`);
            });
        }

        async function startExam(examKey) {
            // ë¬¸ì œì§‘ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë¡œë“œ
            if (!examData[examKey]) {
                await loadProblemSet(examKey);
            }
            
            currentExam = examData[examKey];
            if (!currentExam) {
                alert('ë¬¸ì œì§‘ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            userAnswers = {};
            shuffledOptionsMap = {}; // ì„ì¸ ì„ íƒì§€ ë§¤í•‘ ì´ˆê¸°í™”
            
            document.getElementById('examSelector').classList.add('hidden');
            document.getElementById('examContainer').classList.remove('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            
            document.getElementById('examTitle').textContent = currentExam.title;
            document.getElementById('totalQuestions').textContent = getTotalQuestionCount(currentExam.questions);
            
            renderQuestions();
            updateProgress();
        }

        function renderQuestions() {
            const container = document.getElementById('questionContainer');
            container.innerHTML = '';
            
            let questionNumber = 1;
            
            currentExam.questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question-container';
                
                if (question.type === 'compound') {
                    questionDiv.innerHTML = `
                        <div class="question-header">
                            <span class="question-number">${questionNumber}</span>
                            <span class="question-score">${question.score}ì </span>
                        </div>
                        <div class="question-text">${question.question}</div>
                        <div class="sub-questions">
                            ${question.sub_questions.map((subQ, subIndex) => {
                                const subQuestionHtml = renderSubQuestion(subQ, `${question.id}-${subIndex}`, questionNumber + subIndex);
                                return `<div class="sub-question">${subQuestionHtml}</div>`;
                            }).join('')}
                        </div>
                    `;
                    questionNumber += question.sub_questions.length;
                } else {
                    questionDiv.innerHTML = renderSingleQuestion(question, questionNumber);
                    questionNumber++;
                }
                
                container.appendChild(questionDiv);
            });
            
            setTimeout(renderMath, 100);
        }

        function renderSingleQuestion(question, questionNumber) {
            const questionId = question.id;
            
            let optionsHtml = '';
            
            switch (question.type) {
                case 'single_choice':
                    const shuffledSingleOptions = shuffleOptionsWithMapping(question.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSingleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="radio" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'multiple_choice':
                    const shuffledMultipleOptions = shuffleOptionsWithMapping(question.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledMultipleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="checkbox" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'true_false':
                    optionsHtml = `
                        <div class="options">
                            <div class="option">
                                <input type="radio" id="q${questionId}_true" name="q${questionId}" value="true">
                                <label for="q${questionId}_true">ì°¸</label>
                            </div>
                            <div class="option">
                                <input type="radio" id="q${questionId}_false" name="q${questionId}" value="false">
                                <label for="q${questionId}_false">ê±°ì§“</label>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'short_answer':
                case 'essay':
                    optionsHtml = `
                        <textarea class="text-answer" id="q${questionId}" placeholder="ë‹µì•ˆì„ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
                    `;
                    break;
            }
            
            return `
                <div class="question-header">
                    <span class="question-number">${questionNumber}</span>
                    <span class="question-score">${question.score}ì </span>
                </div>
                <div class="question-text">${question.question}</div>
                ${optionsHtml}
            `;
        }

        function renderSubQuestion(subQuestion, questionId, questionNumber) {
            let optionsHtml = '';
            
            switch (subQuestion.type) {
                case 'single_choice':
                    const shuffledSubSingleOptions = shuffleOptionsWithMapping(subQuestion.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSubSingleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="radio" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'multiple_choice':
                    const shuffledSubMultipleOptions = shuffleOptionsWithMapping(subQuestion.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSubMultipleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="checkbox" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'true_false':
                    optionsHtml = `
                        <div class="options">
                            <div class="option">
                                <input type="radio" id="q${questionId}_true" name="q${questionId}" value="true">
                                <label for="q${questionId}_true">ì°¸</label>
                            </div>
                            <div class="option">
                                <input type="radio" id="q${questionId}_false" name="q${questionId}" value="false">
                                <label for="q${questionId}_false">ê±°ì§“</label>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'short_answer':
                case 'essay':
                    optionsHtml = `
                        <textarea class="text-answer" id="q${questionId}" placeholder="ë‹µì•ˆì„ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
                    `;
                    break;
            }
            
            return `
                <div class="question-header">
                    <span class="question-number">${questionNumber}</span>
                    <span class="question-score">${subQuestion.score}ì </span>
                </div>
                <div class="question-text">${subQuestion.question}</div>
                ${optionsHtml}
            `;
        }

        function updateProgress() {
            document.getElementById('progressFill').style.width = '0%';
        }

        async function submitAnswers() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="loading"></span> ì±„ì  ì¤‘...';
            
            // ë‹µì•ˆ ìˆ˜ì§‘
            collectAnswers();
            
            // ì±„ì  ìˆ˜í–‰
            const results = await gradeAnswers();
            
            // ê²°ê³¼ í‘œì‹œ
            showResults(results);
            
            submitBtn.disabled = false;
            submitBtn.innerHTML = 'ë‹µì•ˆ ì œì¶œ';
        }

        function collectAnswers() {
            userAnswers = {};
            
            currentExam.questions.forEach((question, index) => {
                if (question.type === 'compound') {
                    question.sub_questions.forEach((subQ, subIndex) => {
                        const questionId = `${question.id}-${subIndex}`;
                        userAnswers[questionId] = collectSingleAnswer(subQ, questionId);
                    });
                } else {
                    userAnswers[question.id] = collectSingleAnswer(question, question.id);
                }
            });
        }

        function collectSingleAnswer(question, questionId) {
            switch (question.type) {
                case 'single_choice':
                    const radio = document.querySelector(`input[name="q${questionId}"]:checked`);
                    if (radio) {
                        const shuffledIndex = parseInt(radio.value);
                        // ì„ì¸ ì¸ë±ìŠ¤ë¥¼ ì›ë³¸ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
                        const mapping = shuffledOptionsMap[questionId];
                        return mapping ? mapping.shuffledToOriginal[shuffledIndex] : shuffledIndex;
                    }
                    return null;
                    
                case 'multiple_choice':
                    const checkboxes = document.querySelectorAll(`input[name="q${questionId}"]:checked`);
                    const shuffledIndices = Array.from(checkboxes).map(cb => parseInt(cb.value));
                    // ì„ì¸ ì¸ë±ìŠ¤ë“¤ì„ ì›ë³¸ ì¸ë±ìŠ¤ë“¤ë¡œ ë³€í™˜
                    const mapping = shuffledOptionsMap[questionId];
                    if (mapping) {
                        return shuffledIndices.map(index => mapping.shuffledToOriginal[index]);
                    }
                    return shuffledIndices;
                    
                case 'true_false':
                    const tfRadio = document.querySelector(`input[name="q${questionId}"]:checked`);
                    return tfRadio ? tfRadio.value : null;
                    
                case 'short_answer':
                case 'essay':
                    const textarea = document.getElementById(`q${questionId}`);
                    return textarea ? textarea.value.trim() : '';
                    
                default:
                    return null;
            }
        }

        async function gradeAnswers() {
            const results = {};
            
            for (const question of currentExam.questions) {
                if (question.type === 'compound') {
                    for (let subIndex = 0; subIndex < question.sub_questions.length; subIndex++) {
                        const subQ = question.sub_questions[subIndex];
                        const questionId = `${question.id}-${subIndex}`;
                        const userAnswer = userAnswers[questionId];
                        
                        if (subQ.type === 'essay') {
                            results[questionId] = await gradeEssayWithAPI(subQ, userAnswer);
                        } else {
                            results[questionId] = gradeObjectiveQuestion(subQ, userAnswer);
                        }
                    }
                } else {
                    const questionId = question.id;
                    const userAnswer = userAnswers[questionId];
                    
                    if (question.type === 'essay') {
                        results[questionId] = await gradeEssayWithAPI(question, userAnswer);
                    } else {
                        results[questionId] = gradeObjectiveQuestion(question, userAnswer);
                    }
                }
            }
            
            return results;
        }

        function gradeObjectiveQuestion(question, userAnswer) {
            let isCorrect = false;
            let score = 0;
            
            switch (question.type) {
                case 'single_choice':
                    isCorrect = parseInt(userAnswer) === question.correct_answer;
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'multiple_choice':
                    const correctAnswers = question.correct_answers.sort();
                    const userAnswersSorted = (userAnswer || []).sort();
                    isCorrect = JSON.stringify(correctAnswers) === JSON.stringify(userAnswersSorted);
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'true_false':
                    const correctAnswer = question.correct_answer.toString();
                    isCorrect = userAnswer === correctAnswer;
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'short_answer':
                    isCorrect = userAnswer && userAnswer.toLowerCase() === question.correct_answer.toLowerCase();
                    score = isCorrect ? question.score : 0;
                    break;
            }
            
            return {
                isCorrect,
                score,
                maxScore: question.score,
                userAnswer,
                correctAnswer: question.correct_answer || question.correct_answers,
                explanation: question.explanation
            };
        }

        async function gradeEssayQuestion(question, userAnswer) {
            if (!apiKey) {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer,
                    explanation: question.explanation,
                    feedback: "API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•„ ì£¼ê´€ì‹ ë¬¸ì œë¥¼ ì±„ì í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
                };
            }

            if (!userAnswer || userAnswer.trim() === '') {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer: '',
                    explanation: question.explanation,
                    feedback: "ë‹µì•ˆì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
                };
            }

            // ë¸Œë¼ìš°ì € ì œí•œìœ¼ë¡œ ì¸í•´ ì§ì ‘ OpenAI API í˜¸ì¶œì´ ì–´ë ¤ìš°ë¯€ë¡œ 
            // ì„ì‹œë¡œ ê°„ë‹¨í•œ í‚¤ì›Œë“œ ê¸°ë°˜ ì±„ì ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
            return gradeEssaySimple(question, userAnswer);
        }

        function gradeEssaySimple(question, userAnswer) {
            // ê°„ë‹¨í•œ í‚¤ì›Œë“œ ê¸°ë°˜ ì±„ì  ì‹œìŠ¤í…œ
            const answerLower = userAnswer.toLowerCase();
            let score = 0;
            let feedback = "";
            
            // ê¸°ë³¸ ì ìˆ˜ (ë‹µì•ˆì„ ì‘ì„±í–ˆìœ¼ë©´ ê¸°ë³¸ì ìˆ˜ ë¶€ì—¬)
            if (userAnswer.length > 10) {
                score = Math.floor(question.score * 0.3); // 30% ê¸°ë³¸ì ìˆ˜
                feedback = "ë‹µì•ˆì„ ì„±ì‹¤íˆ ì‘ì„±í–ˆìŠµë‹ˆë‹¤. ";
            }
            
            // ë¬¸ì œë³„ í‚¤ì›Œë“œ ì±„ì 
            if (question.question.includes("í”¼íƒ€ê³ ë¼ìŠ¤")) {
                const keywords = ["aÂ²+bÂ²=cÂ²", "a^2+b^2=c^2", "ì§ê°ì‚¼ê°í˜•", "ë¹—ë³€", "ì œê³±", "ë£¨íŠ¸"];
                let keywordCount = 0;
                keywords.forEach(keyword => {
                    if (answerLower.includes(keyword.toLowerCase())) {
                        keywordCount++;
                    }
                });
                
                if (keywordCount >= 3) {
                    score = question.score; // ë§Œì 
                    feedback += "í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ë¥¼ ì •í™•íˆ ì´í•´í•˜ê³  ê³„ì‚°ì„ ì˜¬ë°”ë¥´ê²Œ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤.";
                } else if (keywordCount >= 2) {
                    score = Math.floor(question.score * 0.7); // 70%
                    feedback += "í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ì˜ ê°œë…ì€ ì´í•´í–ˆìœ¼ë‚˜ ì„¤ëª…ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.";
                } else if (keywordCount >= 1) {
                    score = Math.floor(question.score * 0.5); // 50%
                    feedback += "í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ì— ëŒ€í•œ ê¸°ë³¸ ì´í•´ëŠ” ìˆìœ¼ë‚˜ ë” ìì„¸í•œ ì„¤ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤.";
                }
            }
            
            else if (question.question.includes("ë‰´í„´") && question.question.includes("ì œ3ë²•ì¹™")) {
                const keywords = ["ì‘ìš©", "ë°˜ì‘ìš©", "ê°™ì€", "í¬ê¸°", "ë°˜ëŒ€", "ë°©í–¥", "í˜", "ë²•ì¹™"];
                let keywordCount = 0;
                keywords.forEach(keyword => {
                    if (answerLower.includes(keyword.toLowerCase())) {
                        keywordCount++;
                    }
                });
                
                if (keywordCount >= 4) {
                    score = question.score;
                    feedback += "ë‰´í„´ ì œ3ë²•ì¹™ì„ ì •í™•íˆ ì„¤ëª…í–ˆìŠµë‹ˆë‹¤.";
                } else if (keywordCount >= 2) {
                    score = Math.floor(question.score * 0.7);
                    feedback += "ë‰´í„´ ì œ3ë²•ì¹™ì˜ ê¸°ë³¸ ê°œë…ì€ ë§ìœ¼ë‚˜ ë” ì •í™•í•œ ì„¤ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤.";
                }
            }
            
            // ë‹µì•ˆ ê¸¸ì´ì— ë”°ë¥¸ ì¶”ê°€ ì ìˆ˜ ì¡°ì •
            if (userAnswer.length < 20) {
                score = Math.min(score, Math.floor(question.score * 0.4));
                feedback += " ë‹µì•ˆì´ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤.";
            } else if (userAnswer.length > 100) {
                feedback += " ìƒì„¸í•œ ë‹µì•ˆì„ ì‘ì„±í–ˆìŠµë‹ˆë‹¤.";
            }
            
            return {
                isCorrect: score === question.score,
                score: Math.min(score, question.score),
                maxScore: question.score,
                userAnswer,
                explanation: question.explanation,
                feedback: feedback || "ë‹µì•ˆì„ ê²€í† í•´ë³´ì„¸ìš”."
            };
        }

        // ìƒˆë¡œìš´ AI ì±„ì  ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜
        async function gradeEssayWithAPI(question, userAnswer) {
            try {
                console.log('ğŸ¤– Using new AI grading system...');
                
                if (!authToken) {
                    console.error('No auth token available');
                    return gradeEssayFallback(question, userAnswer);
                }
                
                const response = await fetch('/api/grade-essay', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        question: question,
                        userAnswer: userAnswer,
                        maxScore: question.score
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`AI grading API failed: ${response.status}`, errorText);
                    throw new Error(`API request failed: ${response.status}`);
                }

                const result = await response.json();
                console.log('âœ… AI grading successful:', result.method);
                
                return {
                    isCorrect: result.isCorrect,
                    score: result.score,
                    maxScore: question.score,
                    userAnswer: userAnswer,
                    explanation: question.explanation,
                    feedback: result.feedback,
                    strengths: result.strengths,
                    improvements: result.improvements,
                    method: result.method,
                    timestamp: result.timestamp
                };
                
            } catch (error) {
                console.error('AI grading failed, using fallback:', error.message);
                // ì‹¤íŒ¨ì‹œ ê°œì„ ëœ fallback ì±„ì ìœ¼ë¡œ ëŒ€ì²´
                return gradeEssayFallback(question, userAnswer);
            }
        }
        
        // ê°œì„ ëœ fallback ì±„ì  ì‹œìŠ¤í…œ
        function gradeEssayFallback(question, userAnswer) {
            console.log('ğŸ“ Using improved fallback grading...');
            
            const answerLower = userAnswer.toLowerCase();
            let score = 0;
            let feedback = "";
            let strengths = "";
            let improvements = "";
            
            // ë‹µì•ˆì´ ë„ˆë¬´ ì§§ì€ ê²½ìš°
            if (userAnswer.trim().length < 5) {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer: userAnswer,
                    explanation: question.explanation,
                    feedback: "ë‹µì•ˆì´ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤. ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ” ë‚´ìš©ì„ ìì„¸íˆ ì‘ì„±í•´ì£¼ì„¸ìš”.",
                    strengths: "ë¬¸ì œì— ì‘ë‹µí•˜ë ¤ëŠ” ì˜ì§€ë¥¼ ë³´ì˜€ìŠµë‹ˆë‹¤.",
                    improvements: "ë” ìì„¸í•œ ì„¤ëª…ê³¼ ê³„ì‚° ê³¼ì •ì„ í¬í•¨í•´ì£¼ì„¸ìš”.",
                    method: 'fallback'
                };
            }
            
            // ê¸°ë³¸ ë…¸ë ¥ ì ìˆ˜
            let baseScore = Math.floor(question.score * 0.4); // 40%
            
            // ìˆ˜í•™ì  í‘œí˜„ íƒì§€
            const hasFormula = /(\d+\s*[\+\-\*\/\^Â²]\s*\d+)|([a-z]Â²?\s*[\+\-\*\/]\s*[a-z]Â²?)|(=\s*\d+)/.test(answerLower);
            const hasCalculation = /\d+/.test(userAnswer);
            
            // í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ ë¬¸ì œ íŠ¹ë³„ ì²˜ë¦¬
            if (question.question.includes("í”¼íƒ€ê³ ë¼ìŠ¤") || question.question.includes("pythagorean")) {
                // ì •í™•í•œ ê³„ì‚° í™•ì¸ (5Â² - 3Â² = 16, ë‹µ = 4)
                const hasCorrectCalculation = 
                    (answerLower.includes("25") && answerLower.includes("9") && answerLower.includes("16")) ||
                    (answerLower.includes("5Â²") && answerLower.includes("3Â²")) ||
                    (answerLower.includes("5^2") && answerLower.includes("3^2")) ||
                    (answerLower.includes("4Â²") || answerLower.includes("= 4") || answerLower.includes("ë‹µì€ 4") || answerLower.includes("ì •ë‹µì€ 4"));
                
                if (hasCorrectCalculation) {
                    score = Math.floor(question.score * 0.85); // 85% ì •í™•í•œ ê³„ì‚°
                    feedback = "ìˆ˜í•™ì  ê³„ì‚°ì´ ì •í™•í•©ë‹ˆë‹¤! ";
                    strengths = "í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì ìš©í•˜ì—¬ ì •í™•í•œ ë‹µì„ ë„ì¶œí–ˆìŠµë‹ˆë‹¤.";
                    improvements = "í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ì˜ ê°œë… ì„¤ëª…ì„ ì¶”ê°€í•˜ë©´ ë” ì™„ë²½í•œ ë‹µì•ˆì´ ë©ë‹ˆë‹¤.";
                } else if (hasFormula && hasCalculation) {
                    score = Math.floor(question.score * 0.6); // 60%
                    feedback = "ìˆ˜í•™ì  ì ‘ê·¼ì„ ì‹œë„í–ˆìŠµë‹ˆë‹¤. ";
                    strengths = "ê³µì‹ì„ ì‚¬ìš©í•˜ë ¤ê³  ë…¸ë ¥í–ˆìŠµë‹ˆë‹¤.";
                    improvements = "ê³„ì‚° ê³¼ì •ì„ ë” ì •í™•í•˜ê²Œ í™•ì¸í•´ë³´ì„¸ìš”.";
                } else if (hasCalculation) {
                    score = Math.floor(question.score * 0.5); // 50%
                    feedback = "ê³„ì‚°ì„ ì‹œë„í–ˆìŠµë‹ˆë‹¤. ";
                    strengths = "ìˆ˜ì¹˜ì  ì ‘ê·¼ì„ ì‹œë„í–ˆìŠµë‹ˆë‹¤.";
                    improvements = "í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ ê³µì‹(aÂ²+bÂ²=cÂ²)ì„ í™œìš©í•´ë³´ì„¸ìš”.";
                } else {
                    score = baseScore;
                    feedback = "ë‹µì•ˆì„ ì‘ì„±í–ˆìœ¼ë‚˜ ê³„ì‚°ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ";
                    strengths = "ë¬¸ì œì— ì‘ë‹µí•˜ë ¤ê³  ë…¸ë ¥í–ˆìŠµë‹ˆë‹¤.";
                    improvements = "ìˆ˜ì¹˜ ê³„ì‚°ê³¼ ê³µì‹ ì ìš©ì„ í¬í•¨í•´ì£¼ì„¸ìš”.";
                }
            } else {
                // ì¼ë°˜ ì„œìˆ í˜• ë¬¸ì œ
                if (userAnswer.length > 100) {
                    score = Math.floor(question.score * 0.7);
                    feedback = "ìì„¸í•œ ë‹µì•ˆì„ ì‘ì„±í–ˆìŠµë‹ˆë‹¤. ";
                } else if (userAnswer.length > 50) {
                    score = Math.floor(question.score * 0.6);
                    feedback = "ì ì ˆí•œ ê¸¸ì´ì˜ ë‹µì•ˆì„ ì‘ì„±í–ˆìŠµë‹ˆë‹¤. ";
                } else {
                    score = baseScore;
                    feedback = "ë‹µì•ˆì´ ë‹¤ì†Œ ì§§ìŠµë‹ˆë‹¤. ";
                }
                
                strengths = "ë¬¸ì œì— ì„±ì‹¤íˆ ì‘ë‹µí–ˆìŠµë‹ˆë‹¤.";
                improvements = "ë” êµ¬ì²´ì ì¸ ì„¤ëª…ê³¼ ì˜ˆì‹œë¥¼ í¬í•¨í•˜ë©´ ì¢‹ê² ìŠµë‹ˆë‹¤.";
            }
            
            return {
                isCorrect: score >= question.score * 0.7,
                score: Math.min(score, question.score),
                maxScore: question.score,
                userAnswer: userAnswer,
                explanation: question.explanation,
                feedback: feedback + "(ê°œì„ ëœ ê¸°ë³¸ ì±„ì  ì‹œìŠ¤í…œ ì‚¬ìš©)",
                strengths: strengths,
                improvements: improvements,
                method: 'fallback'
            };
        }

        function showResults(results) {
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.remove('hidden');
            
            let totalScore = 0;
            let maxTotalScore = 0;
            
            // ì ìˆ˜ ê³„ì‚°
            for (const result of Object.values(results)) {
                totalScore += result.score;
                maxTotalScore += result.maxScore;
            }
            
            // ì ìˆ˜ í‘œì‹œ
            const percentage = Math.round((totalScore / maxTotalScore) * 100);
            document.getElementById('finalScore').textContent = `${totalScore}/${maxTotalScore}ì  (${percentage}%)`;
            
            let scoreDescription = '';
            if (percentage >= 90) {
                scoreDescription = 'ğŸ‰ í›Œë¥­í•©ë‹ˆë‹¤! ë§¤ìš° ìš°ìˆ˜í•œ ì„±ì ì…ë‹ˆë‹¤.';
            } else if (percentage >= 80) {
                scoreDescription = 'ğŸ‘ ì˜í–ˆìŠµë‹ˆë‹¤! ì¢‹ì€ ì„±ì ì…ë‹ˆë‹¤.';
            } else if (percentage >= 70) {
                scoreDescription = 'ğŸ‘ ê´œì°®ìŠµë‹ˆë‹¤! ì¡°ê¸ˆë§Œ ë” ë…¸ë ¥í•˜ë©´ ë©ë‹ˆë‹¤.';
            } else if (percentage >= 60) {
                scoreDescription = 'ğŸ“š ë” ê³µë¶€ê°€ í•„ìš”í•©ë‹ˆë‹¤.';
            } else {
                scoreDescription = 'ğŸ’ª í¬ê¸°í•˜ì§€ ë§ê³  ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!';
            }
            document.getElementById('scoreDescription').textContent = scoreDescription;
            
            // ë‹µì•ˆ ê²€í†  í‘œì‹œ
            const reviewsContainer = document.getElementById('answerReviews');
            reviewsContainer.innerHTML = '';
            
            let questionNumber = 1;
            
            currentExam.questions.forEach((question) => {
                if (question.type === 'compound') {
                    const compoundDiv = document.createElement('div');
                    compoundDiv.innerHTML = `<h3>${question.question}</h3>`;
                    
                    question.sub_questions.forEach((subQ, subIndex) => {
                        const questionId = `${question.id}-${subIndex}`;
                        const result = results[questionId];
                        
                        const reviewDiv = createAnswerReview(subQ, result, questionNumber);
                        
                        // ê°œë³„ ë¬¸ì œ ë§í¬ ì¶”ê°€
                        const linkDiv = document.createElement('div');
                        linkDiv.style.cssText = 'margin: 10px 0; text-align: right;';
                        linkDiv.innerHTML = `
                            <button class="btn" onclick="navigateToProblem('${currentExam.key || Object.keys(examData).find(key => examData[key] === currentExam)}', ${question.id})" 
                                    style="background: #4299e1; font-size: 0.8rem; padding: 5px 10px;">
                                ğŸ”— ì´ ë¬¸ì œë§Œ ë³´ê¸°
                            </button>
                        `;
                        reviewDiv.appendChild(linkDiv);
                        
                        compoundDiv.appendChild(reviewDiv);
                        questionNumber++;
                    });
                    
                    reviewsContainer.appendChild(compoundDiv);
                } else {
                    const result = results[question.id];
                    const reviewDiv = createAnswerReview(question, result, questionNumber);
                    
                    // ê°œë³„ ë¬¸ì œ ë§í¬ ì¶”ê°€
                    const linkDiv = document.createElement('div');
                    linkDiv.style.cssText = 'margin: 10px 0; text-align: right;';
                    linkDiv.innerHTML = `
                        <button class="btn" onclick="navigateToProblem('${currentExam.key || Object.keys(examData).find(key => examData[key] === currentExam)}', ${question.id})" 
                                style="background: #4299e1; font-size: 0.8rem; padding: 5px 10px;">
                            ğŸ”— ì´ ë¬¸ì œë§Œ ë³´ê¸°
                        </button>
                    `;
                    reviewDiv.appendChild(linkDiv);
                    
                    reviewsContainer.appendChild(reviewDiv);
                    questionNumber++;
                }
            });
            
            setTimeout(renderMath, 100);
        }

        function createAnswerReview(question, result, questionNumber) {
            const reviewDiv = document.createElement('div');
            
            let statusClass = 'incorrect';
            let statusText = 'í‹€ë¦¼';
            
            if (result.isCorrect) {
                statusClass = 'correct';
                statusText = 'ì •ë‹µ';
            } else if (result.score > 0) {
                statusClass = 'partial';
                statusText = 'ë¶€ë¶„ ì •ë‹µ';
            }
            
            reviewDiv.className = `answer-review ${statusClass}`;
            
            let userAnswerText = '';
            if (question.type === 'multiple_choice') {
                const selectedOptions = (result.userAnswer || []).map(index => question.options[index]);
                userAnswerText = selectedOptions.length > 0 ? selectedOptions.join(', ') : 'ì„ íƒí•˜ì§€ ì•ŠìŒ';
            } else if (question.type === 'single_choice') {
                userAnswerText = result.userAnswer !== null ? question.options[result.userAnswer] : 'ì„ íƒí•˜ì§€ ì•ŠìŒ';
            } else if (question.type === 'true_false') {
                userAnswerText = result.userAnswer === 'true' ? 'ì°¸' : result.userAnswer === 'false' ? 'ê±°ì§“' : 'ì„ íƒí•˜ì§€ ì•ŠìŒ';
            } else {
                userAnswerText = result.userAnswer || 'ë‹µì•ˆ ì—†ìŒ';
            }
            
            let correctAnswerText = '';
            if (question.type === 'multiple_choice') {
                correctAnswerText = question.correct_answers.map(index => question.options[index]).join(', ');
            } else if (question.type === 'single_choice') {
                correctAnswerText = question.options[question.correct_answer];
            } else if (question.type === 'true_false') {
                correctAnswerText = question.correct_answer ? 'ì°¸' : 'ê±°ì§“';
            } else if (question.type === 'short_answer') {
                correctAnswerText = question.correct_answer;
            } else {
                correctAnswerText = 'ì£¼ê´€ì‹ ë¬¸ì œ';
            }
            
            // ì±„ì  ë°©ë²• í‘œì‹œ (AI vs Fallback)
            let gradingMethodBadge = '';
            if (result.method === 'ai') {
                gradingMethodBadge = '<span class="method-badge ai">ğŸ¤– AI ì±„ì </span>';
            } else if (result.method === 'fallback') {
                gradingMethodBadge = '<span class="method-badge fallback">ğŸ“ ê¸°ë³¸ ì±„ì </span>';
            }
            
            reviewDiv.innerHTML = `
                <div class="status-badge ${statusClass}">${statusText} (${result.score}/${result.maxScore}ì ) ${gradingMethodBadge}</div>
                <h4>ë¬¸ì œ ${questionNumber}: ${question.question}</h4>
                <p><strong>ë‚´ ë‹µì•ˆ:</strong> ${userAnswerText}</p>
                ${question.type !== 'essay' ? `<p><strong>ì •ë‹µ:</strong> ${correctAnswerText}</p>` : ''}
                ${result.feedback ? `
                    <div class="ai-feedback">
                        <strong>ğŸ“ ì¢…í•© í”¼ë“œë°±:</strong>
                        <p>${result.feedback}</p>
                    </div>
                ` : ''}
                ${result.strengths ? `
                    <div class="feedback-strengths">
                        <strong>âœ… ì˜í•œ ì :</strong>
                        <p>${result.strengths}</p>
                    </div>
                ` : ''}
                ${result.improvements ? `
                    <div class="feedback-improvements">
                        <strong>ğŸ’¡ ê°œì„  ì‚¬í•­:</strong>
                        <p>${result.improvements}</p>
                    </div>
                ` : ''}
                <div class="explanation">
                    <strong>ğŸ“š í•´ì„¤:</strong> ${result.explanation}
                </div>
                ${result.timestamp ? `
                    <div class="grading-info">
                        <small>ì±„ì  ì‹œê°„: ${new Date(result.timestamp).toLocaleString('ko-KR')}</small>
                    </div>
                ` : ''}
            `;
            
            return reviewDiv;
        }

        async function showProblemList(problemSetKey) {
            // ë¬¸ì œì§‘ ë¡œë“œ
            if (!examData[problemSetKey]) {
                await loadProblemSet(problemSetKey);
            }
            
            const problemSet = examData[problemSetKey];
            if (!problemSet) {
                alert('ë¬¸ì œì§‘ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            // ê¸°ì¡´ í™”ë©´ ìˆ¨ê¸°ê¸°
            document.getElementById('examSelector').classList.add('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            document.getElementById('singleProblemContainer').classList.add('hidden');
            
            // ë¬¸ì œ ëª©ë¡ ì»¨í…Œì´ë„ˆ ìƒì„± ë˜ëŠ” í‘œì‹œ
            let listContainer = document.getElementById('problemListContainer');
            if (!listContainer) {
                listContainer = document.createElement('div');
                listContainer.id = 'problemListContainer';
                listContainer.className = 'card hidden';
                document.querySelector('.container').appendChild(listContainer);
            }
            
            listContainer.classList.remove('hidden');
            
            // í—¤ë” ìƒì„±
            const header = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <div>
                        <h2>${problemSet.title} - ë¬¸ì œ ëª©ë¡</h2>
                        <p>${problemSet.description}</p>
                    </div>
                    <div>
                        <button class="btn" onclick="navigateToHome()" style="background: #718096;">ëª©ë¡ìœ¼ë¡œ</button>
                        <button class="btn" onclick="startExam('${problemSetKey}')" style="background: #38a169;">ì „ì²´ ì‹œí—˜ ì‹œì‘</button>
                    </div>
                </div>
            `;
            
            // ë¬¸ì œ ëª©ë¡ ìƒì„±
            let problemListHtml = '';
            let questionNumber = 1;
            
            problemSet.questions.forEach((question) => {
                if (question.type === 'compound') {
                    problemListHtml += `
                        <div class="question-container" style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1;">
                                    <h4>ë¬¸ì œ ${questionNumber}: ${question.question.substring(0, 100)}${question.question.length > 100 ? '...' : ''}</h4>
                                    <p style="color: #718096; margin: 5px 0;">ë³µí•© ë¬¸ì œ (${question.sub_questions.length}ê°œ í•˜ìœ„ ë¬¸ì œ) | ${question.score}ì </p>
                                </div>
                                <div>
                                    <button class="btn" onclick="navigateToProblem('${problemSetKey}', ${question.id})" 
                                            style="background: #4299e1; font-size: 0.9rem; padding: 8px 16px;">
                                        ğŸ“ í’€ì–´ë³´ê¸°
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                    questionNumber += question.sub_questions.length;
                } else {
                    const typeText = {
                        'single_choice': 'ê°ê´€ì‹(ë‹¨ì¼ì„ íƒ)',
                        'multiple_choice': 'ê°ê´€ì‹(ë‹¤ì¤‘ì„ íƒ)', 
                        'true_false': 'O/X',
                        'short_answer': 'ë‹¨ë‹µí˜•',
                        'essay': 'ì„œìˆ í˜•'
                    }[question.type] || question.type;
                    
                    problemListHtml += `
                        <div class="question-container" style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1;">
                                    <h4>ë¬¸ì œ ${questionNumber}: ${question.question.substring(0, 100)}${question.question.length > 100 ? '...' : ''}</h4>
                                    <p style="color: #718096; margin: 5px 0;">${typeText} | ${question.score}ì </p>
                                </div>
                                <div>
                                    <button class="btn" onclick="navigateToProblem('${problemSetKey}', ${question.id})" 
                                            style="background: #4299e1; font-size: 0.9rem; padding: 8px 16px;">
                                        ğŸ“ í’€ì–´ë³´ê¸°
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                    questionNumber++;
                }
            });
            
            listContainer.innerHTML = `
                ${header}
                <div style="border-top: 2px solid #e2e8f0; padding-top: 20px;">
                    ${problemListHtml}
                </div>
            `;
            
            setTimeout(renderMath, 100);
        }

        function resetExam() {
            currentExam = null;
            userAnswers = {};
            shuffledOptionsMap = {}; // ì„ì¸ ì„ íƒì§€ ë§¤í•‘ ì´ˆê¸°í™”
            
            document.getElementById('examSelector').classList.remove('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            document.getElementById('singleProblemContainer').classList.add('hidden');
            document.getElementById('problemListContainer').classList.add('hidden');
        }
    </script>
</body>
</html>
