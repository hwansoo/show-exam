<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>시험 문제 연습 서비스</title>
    <!-- JWT Auth Update -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .exam-selector {
            margin-bottom: 30px;
        }

        .exam-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .exam-card {
            background: linear-gradient(145deg, #f0f4f8, #e2e8f0);
            border: none;
            border-radius: 12px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .exam-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            background: linear-gradient(145deg, #e2e8f0, #cbd5e0);
        }

        .exam-card h3 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .exam-card p {
            color: #718096;
            font-size: 0.95rem;
        }

        .question-container {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8fafc;
            border-radius: 12px;
            border-left: 5px solid #667eea;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .question-score {
            background: #38a169;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
            line-height: 1.7;
        }

        .sub-questions {
            margin-left: 20px;
            border-left: 3px solid #e2e8f0;
            padding-left: 20px;
        }

        .sub-question {
            margin-bottom: 20px;
        }

        .options {
            margin: 15px 0;
        }

        .option {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }

        .option:hover {
            background-color: #f1f5f9;
        }

        .option input {
            margin-right: 12px;
            transform: scale(1.2);
        }

        .option label {
            cursor: pointer;
            flex: 1;
        }

        .text-answer {
            width: 100%;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
            resize: vertical;
            min-height: 100px;
        }

        .text-answer:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-container {
            margin-top: 30px;
        }

        .score-display {
            text-align: center;
            padding: 30px;
            background: linear-gradient(145deg, #48bb78, #38a169);
            color: white;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .score-display h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .answer-review {
            margin-bottom: 25px;
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #cbd5e0;
        }

        .answer-review.correct {
            background: #f0fff4;
            border-left-color: #48bb78;
        }

        .answer-review.incorrect {
            background: #fff5f5;
            border-left-color: #f56565;
        }

        .answer-review.partial {
            background: #fffbf0;
            border-left-color: #ed8936;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status-badge.correct {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-badge.incorrect {
            background: #fed7d7;
            color: #742a2a;
        }

        .status-badge.partial {
            background: #feebc8;
            color: #744210;
        }

        .explanation {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #667eea;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* New AI grading feedback styles */
        .method-badge {
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .method-badge.ai {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .method-badge.fallback {
            background: #f7fafc;
            color: #4a5568;
            border: 1px solid #e2e8f0;
        }
        
        .ai-feedback {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border-radius: 8px;
            border-left: 4px solid #0ea5e9;
        }
        
        .feedback-strengths {
            margin-top: 12px;
            padding: 12px;
            background: linear-gradient(135deg, #f0fdf4, #ecfdf5);
            border-radius: 8px;
            border-left: 4px solid #22c55e;
        }
        
        .feedback-improvements {
            margin-top: 12px;
            padding: 12px;
            background: linear-gradient(135deg, #fffbeb, #fef3c7);
            border-radius: 8px;
            border-left: 4px solid #f59e0b;
        }
        
        .grading-info {
            margin-top: 10px;
            text-align: right;
            opacity: 0.7;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        .api-key-input {
            margin-bottom: 20px;
            padding: 20px;
            background: #f0f4f8;
            border-radius: 10px;
        }

        .api-key-input input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .card {
                padding: 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📚 시험 문제 연습 서비스</h1>
            <p>다양한 유형의 문제를 풀고 실력을 향상시켜보세요!</p>
        </div>

        <!-- 전역 비밀번호 보호 화면 -->
        <div class="card" id="globalPasswordSection">
            <div style="text-align: center; padding: 40px 20px;">
                <h2>🔐 서비스 접속</h2>
                <p style="margin: 20px 0; color: #718096;">이 서비스는 비밀번호로 보호되고 있습니다.</p>
                <div style="max-width: 300px; margin: 0 auto;">
                    <input type="password" id="globalPasswordInput" placeholder="접속 비밀번호를 입력하세요" 
                           style="width: 100%; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; margin-bottom: 15px; text-align: center;">
                    <button class="btn" onclick="checkGlobalPassword()" style="width: 100%;">🚀 접속하기</button>
                    <div id="globalPasswordError" style="color: #e53e3e; margin-top: 10px; font-size: 0.9rem; display: none;">
                        ❌ 비밀번호가 올바르지 않습니다.
                    </div>
                </div>
            </div>
        </div>

        <!-- 메인 서비스 컨테이너 (비밀번호 확인 후 표시) -->
        <div id="mainServiceContainer" class="hidden">

        <!-- API Key 설정 -->
        <div class="card api-key-input" id="apiKeySection">
            <h3>🔑 OpenAI API 키 설정</h3>
            <p>주관식 문제 채점을 위해 OpenAI API 키가 필요합니다.</p>
            <input type="password" id="apiKeyInput" placeholder="OpenAI API 키를 입력하세요">
            <button class="btn" onclick="saveApiKey()">저장</button>
            <button class="btn" onclick="showAdminLogin()" style="float: right; background: linear-gradient(145deg, #e53e3e, #c53030);">🔧 관리자</button>
        </div>

        <!-- 관리자 로그인 -->
        <div class="card hidden" id="adminLoginSection">
            <h3>🔐 관리자 로그인</h3>
            <p>문제집 관리를 위해 관리자 비밀번호를 입력하세요.</p>
            <input type="password" id="adminPasswordInput" placeholder="관리자 비밀번호">
            <button class="btn" onclick="adminLogin()">로그인</button>
            <button class="btn" onclick="hideAdminLogin()" style="background: #718096;">취소</button>
        </div>

        <!-- 관리자 패널 -->
        <div class="card hidden" id="adminPanel">
            <h2>🛠️ 관리자 패널</h2>
            <div style="margin-bottom: 20px;">
                <button class="btn" onclick="showAddProblemSet()">➕ 문제집 추가</button>
                <button class="btn" onclick="hideAdminPanel()" style="background: #718096;">나가기</button>
            </div>
            
            <!-- 문제집 목록 -->
            <div id="adminProblemSetsList">
                <h3>📚 저장된 문제집</h3>
                <div id="problemSetsManagement"></div>
            </div>
        </div>

        <!-- 문제집 추가/편집 폼 -->
        <div class="card hidden" id="addProblemSetForm">
            <h3 id="formTitle">➕ 새 문제집 추가</h3>
            <div style="margin-bottom: 15px;">
                <label for="problemSetKey">문제집 키 (영문, 숫자, 언더스코어만):</label>
                <input type="text" id="problemSetKey" placeholder="예: custom_math_1" style="width: 100%; padding: 10px; margin-top: 5px; border: 2px solid #e2e8f0; border-radius: 8px;">
            </div>
            <div style="margin-bottom: 15px;">
                <label for="problemSetJSON">JSON 데이터:</label>
                <textarea id="problemSetJSON" rows="20" placeholder='JSON 형식으로 문제집을 입력하세요...' style="width: 100%; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; font-family: monospace; font-size: 0.9rem;"></textarea>
            </div>
            <div>
                <button class="btn" onclick="saveProblemSet()" id="saveBtn">저장</button>
                <button class="btn" onclick="hideAddProblemSetForm()" style="background: #718096;">취소</button>
                <button class="btn" onclick="showJSONExample()" style="background: #38a169;">📄 예시 보기</button>
            </div>
        </div>

        <!-- 시험 선택 화면 -->
        <div class="card exam-selector" id="examSelector">
            <h2>📋 시험 선택</h2>
            <div class="exam-grid" id="examGrid">
                <!-- 시험 목록이 여기에 동적으로 생성됩니다 -->
            </div>
        </div>

        <!-- 문제 풀이 화면 -->
        <div class="card hidden" id="examContainer">
            <div id="examHeader">
                <h2 id="examTitle"></h2>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p>문제 <span id="currentQuestion">1</span> / <span id="totalQuestions">10</span></p>
            </div>
            
            <div id="questionContainer">
                <!-- 문제들이 여기에 동적으로 생성됩니다 -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="submitAnswers()" id="submitBtn">답안 제출</button>
                <button class="btn" onclick="resetExam()">처음으로</button>
            </div>
        </div>

        <!-- 결과 화면 -->
        <div class="card hidden" id="resultsContainer">
            <div class="score-display" id="scoreDisplay">
                <h2 id="finalScore"></h2>
                <p id="scoreDescription"></p>
            </div>
            
            <div id="answerReviews">
                <!-- 답안 검토가 여기에 표시됩니다 -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="resetExam()">다시 시작</button>
            </div>
        </div>

        </div> <!-- End of mainServiceContainer -->
    </div>

    <script>
        // API 설정
        const API_BASE_URL = window.location.hostname === 'localhost' ? '' : '';
        
        // 문제집 데이터 저장소
        let examData = {};
        let problemSetsIndex = null;

        let currentExam = null;
        let userAnswers = {};
        let apiKey = '';
        let isAdminLoggedIn = false;
        let editingProblemSetKey = null;
        let ADMIN_PASSWORD = 'admin123'; // 기본값, 환경변수로 덮어쓰기 가능
        let GLOBAL_PASSWORD = ''; // 전역 접속 비밀번호
        let isGloballyAuthenticated = false;
        let authToken = null; // API 인증 토큰
        let shuffledOptionsMap = {}; // 섞인 선택지의 매핑을 저장
        let currentRoute = null; // 현재 라우트 정보 저장
        
        // 토큰 저장 및 로드 함수
        function saveAuthToken(token) {
            localStorage.setItem('show-exam-auth-token', token);
            authToken = token;
        }
        
        function loadAuthToken() {
            const token = localStorage.getItem('show-exam-auth-token');
            if (token) {
                authToken = token;
                return token;
            }
            return null;
        }
        
        function clearAuthToken() {
            localStorage.removeItem('show-exam-auth-token');
            authToken = null;
        }
        
        // 전역 비밀번호 확인 함수
        async function checkGlobalPassword() {
            const inputPassword = document.getElementById('globalPasswordInput').value.trim();
            const errorDiv = document.getElementById('globalPasswordError');
            
            if (!inputPassword) {
                showPasswordError('비밀번호를 입력해주세요.');
                return;
            }

            try {
                // 서버에서 인증 시도
                const authResult = await apiCall('auth', {
                    method: 'POST',
                    body: JSON.stringify({ password: inputPassword })
                });

                if (authResult.success) {
                    saveAuthToken(authResult.token);
                    isGloballyAuthenticated = true;
                    
                    // 인증 성공 시 메인 서비스 로드
                    await initializeMainService();
                    
                    // UI 전환
                    document.getElementById('globalPasswordSection').classList.add('hidden');
                    document.getElementById('mainServiceContainer').classList.remove('hidden');
                    
                    // 라우팅 초기화 (UI 전환 후)
                    initializeRouting();
                    
                    // 비밀번호 입력창 초기화
                    document.getElementById('globalPasswordInput').value = '';
                    errorDiv.style.display = 'none';
                    
                } else {
                    showPasswordError('비밀번호가 올바르지 않습니다.');
                }
            } catch (error) {
                console.error('Authentication failed:', error);
                showPasswordError('인증 중 오류가 발생했습니다.');
            }
        }

        function showPasswordError(message) {
            const errorDiv = document.getElementById('globalPasswordError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            // 3초 후 에러 메시지 숨기기
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 3000);
        }

        // 메인 서비스 초기화
        async function initializeMainService() {
            await loadEnvironmentVariables();
            updateApiKeyUI();
            await loadProblemSetsIndex();
            await loadExamList();
            renderMath();
        }

        // 환경변수 로드 함수
        async function loadEnvironmentVariables() {
            try {
                // 서버에서 환경변수 로드 (인증 토큰 포함)
                const config = await apiCall('config', {
                    headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {}
                });
                
                if (config.openaiApiKey) {
                    apiKey = config.openaiApiKey;
                    console.log('OpenAI API Key loaded from server environment variables');
                }
                
                if (config.adminPassword) {
                    ADMIN_PASSWORD = config.adminPassword;
                }
                
                if (config.globalPassword) {
                    GLOBAL_PASSWORD = config.globalPassword;
                }
                
            } catch (error) {
                console.error('Failed to load server configuration:', error);
                // Fallback to localStorage
                apiKey = localStorage.getItem('openai_api_key') || '';
            }
            
            // localStorage에서 사용자가 입력한 키가 있으면 우선 사용
            const storedApiKey = localStorage.getItem('openai_api_key');
            if (storedApiKey) {
                apiKey = storedApiKey;
                console.log('Using API key from localStorage (user override)');
            }
        }
        

        // 배열 섞기 함수 (Fisher-Yates shuffle)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // 선택지 섞기 및 매핑 생성
        function shuffleOptionsWithMapping(options, questionId) {
            const indexedOptions = options.map((option, index) => ({ option, originalIndex: index }));
            const shuffled = shuffleArray(indexedOptions);
            
            // 원본 인덱스 -> 섞인 인덱스 매핑
            const originalToShuffled = {};
            // 섞인 인덱스 -> 원본 인덱스 매핑
            const shuffledToOriginal = {};
            
            shuffled.forEach((item, newIndex) => {
                originalToShuffled[item.originalIndex] = newIndex;
                shuffledToOriginal[newIndex] = item.originalIndex;
            });
            
            shuffledOptionsMap[questionId] = {
                originalToShuffled,
                shuffledToOriginal,
                shuffledOptions: shuffled.map(item => item.option)
            };
            
            return shuffled.map(item => item.option);
        }

        // API 함수들
        async function apiCall(endpoint, options = {}) {
            try {
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                // 인증된 경우 토큰 추가 (auth 엔드포인트 제외)
                if (authToken && endpoint !== 'auth') {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE_URL}/api/${endpoint}`, {
                    headers,
                    ...options
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    
                    // 401 Unauthorized - 토큰이 유효하지 않음
                    if (response.status === 401 && authToken) {
                        clearAuthToken();
                        isGloballyAuthenticated = false;
                        // 로그인 화면으로 리다이렉트
                        document.getElementById('globalPasswordSection').classList.remove('hidden');
                        document.getElementById('mainServiceContainer').classList.add('hidden');
                    }
                    
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        async function loadProblemSetsIndex() {
            try {
                if (!authToken) {
                    console.error('No auth token available for API call');
                    return loadFallbackData();
                }
                
                problemSetsIndex = await apiCall('problem-sets');
                console.log('Problem sets index loaded successfully:', problemSetsIndex);
                return problemSetsIndex;
            } catch (error) {
                console.error('Failed to load problem sets index:', error);
                // Fallback to built-in data
                return loadFallbackData();
            }
        }

        async function loadProblemSet(key) {
            try {
                const problemSet = await apiCall(`problem-sets?key=${key}`);
                examData[key] = problemSet;
                return problemSet;
            } catch (error) {
                console.error(`Failed to load problem set ${key}:`, error);
                return null;
            }
        }

        async function saveProblemSetToAPI(key, data) {
            try {
                await apiCall('problem-sets', {
                    method: 'POST',
                    body: JSON.stringify({ key, data })
                });
                return true;
            } catch (error) {
                console.error('Failed to save problem set:', error);
                throw error;
            }
        }

        async function updateProblemSetInAPI(key, data) {
            try {
                await apiCall(`problem-sets?key=${key}`, {
                    method: 'PUT',
                    body: JSON.stringify({ data })
                });
                return true;
            } catch (error) {
                console.error('Failed to update problem set:', error);
                throw error;
            }
        }

        async function deleteProblemSetFromAPI(key) {
            try {
                await apiCall(`problem-sets?key=${key}`, {
                    method: 'DELETE'
                });
                return true;
            } catch (error) {
                console.error('Failed to delete problem set:', error);
                throw error;
            }
        }

        // Fallback 데이터 (API 실패 시 사용)
        function loadFallbackData() {
            console.log('Using fallback data due to API failure');
            
            // 기본 문제집 데이터를 직접 로드
            const fallbackMathData = {
                "title": "기초 수학",
                "description": "기본적인 수학 개념을 다루는 문제들",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "다음 중 $\\sqrt{16}$의 값은?",
                        "options": ["2", "4", "8", "16"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "$\\sqrt{16} = 4$입니다. 16의 제곱근은 4입니다."
                    },
                    {
                        "id": 2,
                        "type": "multiple_choice",
                        "question": "다음 중 소수인 것을 모두 고르세요.",
                        "options": ["2", "3", "4", "5", "6", "7"],
                        "correct_answers": [0, 1, 3, 5],
                        "score": 15,
                        "explanation": "소수는 1과 자기 자신으로만 나누어지는 자연수입니다. 2, 3, 5, 7이 소수입니다."
                    },
                    {
                        "id": 3,
                        "type": "true_false",
                        "question": "$\\pi$는 무리수이다.",
                        "correct_answer": true,
                        "score": 10,
                        "explanation": "$\\pi$는 무리수입니다. 유한소수나 순환소수로 표현할 수 없습니다."
                    }
                ]
            };
            
            const fallbackPhysicsData = {
                "title": "기초 물리학",
                "description": "물리학의 기본 개념과 공식들",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "자유낙하하는 물체의 가속도는 대략 얼마인가?",
                        "options": ["$9.8 \\text{ m/s}$", "$9.8 \\text{ m/s}^2$", "$98 \\text{ m/s}^2$", "$0.98 \\text{ m/s}^2$"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "지구에서 중력가속도는 약 $9.8 \\text{ m/s}^2$입니다."
                    }
                ]
            };
            
            // examData에 fallback 데이터 로드
            examData['math_basic'] = fallbackMathData;
            examData['physics_basic'] = fallbackPhysicsData;
            
            return {
                version: "1.0.0",
                problem_sets: [
                    {
                        key: "math_basic",
                        title: "기초 수학",
                        description: "기본적인 수학 개념을 다루는 문제들",
                        category: "mathematics",
                        is_built_in: true
                    },
                    {
                        key: "physics_basic",
                        title: "기초 물리학", 
                        description: "물리학의 기본 개념과 공식들",
                        category: "physics",
                        is_built_in: true
                    }
                ]
            };
        }

        // 라우팅 시스템
        function initializeRouting() {
            // 페이지 로드 시 URL 확인
            handleRouteChange();
            
            // 브라우저 뒤로가기/앞으로가기 처리
            window.addEventListener('popstate', handleRouteChange);
        }

        function handleRouteChange() {
            const path = window.location.pathname;
            const hash = window.location.hash;
            
            // URL 패턴: /problem/{problemSetKey}/{questionId}
            const problemMatch = path.match(/^\/problem\/([^\/]+)\/(\d+)$/);
            
            if (problemMatch) {
                const [, problemSetKey, questionId] = problemMatch;
                currentRoute = {
                    type: 'problem',
                    problemSetKey,
                    questionId: parseInt(questionId)
                };
                
                // 인증된 상태에서만 문제 표시
                if (isGloballyAuthenticated) {
                    showSpecificProblem(problemSetKey, parseInt(questionId));
                }
            } else if (hash.startsWith('#/problem/')) {
                // Hash 기반 라우팅 지원 (fallback)
                const hashMatch = hash.match(/^#\/problem\/([^\/]+)\/(\d+)$/);
                if (hashMatch) {
                    const [, problemSetKey, questionId] = hashMatch;
                    currentRoute = {
                        type: 'problem',
                        problemSetKey,
                        questionId: parseInt(questionId)
                    };
                    
                    if (isGloballyAuthenticated) {
                        showSpecificProblem(problemSetKey, parseInt(questionId));
                    }
                }
            } else {
                // URL 패턴: /exam/{problemSetKey}
                const examMatch = path.match(/^\/exam\/([^\/]+)$/);
                
                if (examMatch) {
                    const [, problemSetKey] = examMatch;
                    currentRoute = {
                        type: 'exam',
                        problemSetKey
                    };
                    
                    // 인증된 상태에서만 시험 시작
                    if (isGloballyAuthenticated) {
                        startExam(problemSetKey);
                    }
                } else {
                    currentRoute = { type: 'home' };
                    if (isGloballyAuthenticated) {
                        showHome();
                    }
                }
            }
        }

        function navigateToProblem(problemSetKey, questionId) {
            const url = `/problem/${problemSetKey}/${questionId}`;
            history.pushState(null, '', url);
            currentRoute = {
                type: 'problem',
                problemSetKey,
                questionId
            };
            showSpecificProblem(problemSetKey, questionId);
        }

        function navigateToHome() {
            history.pushState(null, '', '/');
            currentRoute = { type: 'home' };
            showHome();
        }

        function showHome() {
            document.getElementById('examSelector').classList.remove('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            document.getElementById('singleProblemContainer').classList.add('hidden');
            const problemListContainer = document.getElementById('problemListContainer');
            if (problemListContainer) {
                problemListContainer.classList.add('hidden');
            }
        }

        async function showSpecificProblem(problemSetKey, questionId) {
            // 문제집 로드
            if (!examData[problemSetKey]) {
                await loadProblemSet(problemSetKey);
            }
            
            const problemSet = examData[problemSetKey];
            if (!problemSet) {
                alert('문제집을 찾을 수 없습니다.');
                navigateToHome();
                return;
            }

            // 문제 찾기
            let targetQuestion = null;
            let questionNumber = 1;
            
            for (const question of problemSet.questions) {
                if (question.type === 'compound') {
                    for (let subIndex = 0; subIndex < question.sub_questions.length; subIndex++) {
                        if (question.id === questionId && subIndex === 0) {
                            // 복합 문제의 경우 전체 문제 표시
                            targetQuestion = question;
                            break;
                        }
                        questionNumber++;
                    }
                } else {
                    if (question.id === questionId) {
                        targetQuestion = question;
                        break;
                    }
                    questionNumber++;
                }
                if (targetQuestion) break;
            }

            if (!targetQuestion) {
                alert('문제를 찾을 수 없습니다.');
                navigateToHome();
                return;
            }

            // 단일 문제 표시
            renderSingleProblemView(problemSet, targetQuestion, questionNumber);
        }

        function renderSingleProblemView(problemSet, question, questionNumber) {
            // 기존 화면 숨기기
            document.getElementById('examSelector').classList.add('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            
            // 단일 문제 컨테이너 표시
            let singleContainer = document.getElementById('singleProblemContainer');
            if (!singleContainer) {
                singleContainer = document.createElement('div');
                singleContainer.id = 'singleProblemContainer';
                singleContainer.className = 'card hidden';
                document.querySelector('.container').appendChild(singleContainer);
            }
            
            singleContainer.classList.remove('hidden');
            
            // 헤더 생성
            const header = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <div>
                        <h2>${problemSet.title}</h2>
                        <p>문제 ${questionNumber}</p>
                    </div>
                    <div>
                        <button class="btn" onclick="navigateToHome()" style="background: #718096;">목록으로</button>
                        <button class="btn" onclick="startExam('${currentRoute.problemSetKey}')" style="background: #38a169;">전체 시험</button>
                    </div>
                </div>
            `;
            
            // 문제 렌더링
            let questionHtml = '';
            if (question.type === 'compound') {
                questionHtml = `
                    <div class="question-container">
                        <div class="question-header">
                            <span class="question-number">${questionNumber}</span>
                            <span class="question-score">${question.score}점</span>
                        </div>
                        <div class="question-text">${question.question}</div>
                        <div class="sub-questions">
                            ${question.sub_questions.map((subQ, subIndex) => {
                                const subQuestionHtml = renderSubQuestion(subQ, `${question.id}-${subIndex}`, questionNumber + subIndex);
                                return `<div class="sub-question">${subQuestionHtml}</div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            } else {
                questionHtml = `
                    <div class="question-container">
                        ${renderSingleQuestion(question, questionNumber)}
                    </div>
                `;
            }
            
            singleContainer.innerHTML = `
                ${header}
                ${questionHtml}
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn" onclick="submitSingleProblem()">답안 확인</button>
                </div>
                <div id="singleProblemResult" class="hidden" style="margin-top: 30px;"></div>
            `;
            
            setTimeout(renderMath, 100);
        }

        async function submitSingleProblem() {
            const question = getCurrentQuestion();
            if (!question) return;
            
            // 답안 수집
            let userAnswer;
            const questionId = question.type === 'compound' ? `${question.id}-0` : question.id;
            
            if (question.type === 'compound') {
                // 복합 문제의 경우 모든 하위 문제 답안 수집
                const subAnswers = {};
                question.sub_questions.forEach((subQ, subIndex) => {
                    const subQuestionId = `${question.id}-${subIndex}`;
                    subAnswers[subQuestionId] = collectSingleAnswer(subQ, subQuestionId);
                });
                userAnswer = subAnswers;
            } else {
                userAnswer = collectSingleAnswer(question, questionId);
            }
            
            // 채점 수행
            let results = {};
            if (question.type === 'compound') {
                for (let subIndex = 0; subIndex < question.sub_questions.length; subIndex++) {
                    const subQ = question.sub_questions[subIndex];
                    const subQuestionId = `${question.id}-${subIndex}`;
                    const subAnswer = userAnswer[subQuestionId];
                    
                    if (subQ.type === 'essay') {
                        results[subQuestionId] = await gradeEssayWithAPI(subQ, subAnswer);
                    } else {
                        results[subQuestionId] = gradeObjectiveQuestion(subQ, subAnswer);
                    }
                }
            } else {
                if (question.type === 'essay') {
                    results[questionId] = await gradeEssayWithAPI(question, userAnswer);
                } else {
                    results[questionId] = gradeObjectiveQuestion(question, userAnswer);
                }
            }
            
            // 결과 표시
            showSingleProblemResult(question, results);
        }

        function getCurrentQuestion() {
            if (!currentRoute || !currentRoute.problemSetKey || !currentRoute.questionId) return null;
            
            const problemSet = examData[currentRoute.problemSetKey];
            if (!problemSet) return null;
            
            return problemSet.questions.find(q => q.id === currentRoute.questionId);
        }

        function showSingleProblemResult(question, results) {
            const resultContainer = document.getElementById('singleProblemResult');
            resultContainer.classList.remove('hidden');
            
            let totalScore = 0;
            let maxTotalScore = 0;
            
            // 점수 계산
            for (const result of Object.values(results)) {
                totalScore += result.score;
                maxTotalScore += result.maxScore;
            }
            
            // 결과 HTML 생성
            let resultHtml = `
                <div class="score-display">
                    <h3>결과: ${totalScore}/${maxTotalScore}점</h3>
                </div>
            `;
            
            if (question.type === 'compound') {
                question.sub_questions.forEach((subQ, subIndex) => {
                    const questionId = `${question.id}-${subIndex}`;
                    const result = results[questionId];
                    const reviewDiv = createAnswerReview(subQ, result, subIndex + 1);
                    resultHtml += reviewDiv.outerHTML;
                });
            } else {
                const result = results[question.id];
                const reviewDiv = createAnswerReview(question, result, 1);
                resultHtml += reviewDiv.outerHTML;
            }
            
            resultContainer.innerHTML = resultHtml;
            setTimeout(renderMath, 100);
        }

        // 초기화
        document.addEventListener('DOMContentLoaded', async function() {
            // 저장된 토큰이 있는지 확인
            const savedToken = loadAuthToken();
            if (savedToken) {
                try {
                    // 토큰 유효성 확인을 위해 API 호출 시도
                    const testResult = await apiCall('problem-sets');
                    if (testResult && !testResult.error) {
                        // 토큰이 유효하면 메인 서비스 로드
                        isGloballyAuthenticated = true;
                        await initializeMainService();
                        initializeRouting(); // 라우팅 초기화
                        document.getElementById('globalPasswordSection').classList.add('hidden');
                        document.getElementById('mainServiceContainer').classList.remove('hidden');
                        return; // 인증 성공 시 여기서 종료
                    }
                } catch (error) {
                    console.log('Saved token is invalid, clearing...');
                }
                // 토큰이 유효하지 않으면 제거
                clearAuthToken();
            }
            
            // 전역 비밀번호 보호가 활성화된 경우 로그인 화면 표시
            // 개발 환경에서는 바로 메인 서비스 로드 (필요시 주석 해제)
            // if (window.location.hostname === 'localhost') {
            //     await initializeMainService();
            //     document.getElementById('globalPasswordSection').classList.add('hidden');
            //     document.getElementById('mainServiceContainer').classList.remove('hidden');
            // }
            
            // Enter 키 지원
            document.getElementById('globalPasswordInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    checkGlobalPassword();
                }
            });
        });
        
        // API 키 UI 업데이트
        function updateApiKeyUI() {
            const apiKeyInput = document.getElementById('apiKeyInput');
            const apiKeySection = document.getElementById('apiKeySection');
            
            if (apiKey) {
                apiKeyInput.value = '***API키가 설정되었습니다***';
                apiKeyInput.disabled = true;
                
                // 환경변수에서 로드된 경우 알림 표시
                const envSource = document.createElement('p');
                envSource.style.cssText = 'color: #38a169; font-size: 0.9rem; margin-top: 5px;';
                envSource.innerHTML = '✅ API 키가 환경변수에서 자동으로 로드되었습니다.';
                
                if (!document.querySelector('.env-source-notice')) {
                    envSource.className = 'env-source-notice';
                    apiKeySection.appendChild(envSource);
                }
            } else {
                // 환경변수에서 로드되지 않은 경우 사용자 입력 허용
                const notice = document.createElement('p');
                notice.style.cssText = 'color: #e53e3e; font-size: 0.9rem; margin-top: 5px;';
                notice.innerHTML = '⚠️ 환경변수에서 API 키를 찾을 수 없습니다. 직접 입력해주세요.';
                notice.className = 'env-source-notice';
                apiKeySection.appendChild(notice);
            }
        }

        function renderMath() {
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ]
                });
            }
        }

        function saveApiKey() {
            const inputElement = document.getElementById('apiKeyInput');
            const key = inputElement.value.trim();
            
            // 환경변수로 이미 설정된 경우 사용자 입력 무시
            if (inputElement.disabled) {
                alert('API 키가 이미 환경변수에서 설정되었습니다.');
                return;
            }
            
            if (key && key !== '***API키가 설정되었습니다***') {
                apiKey = key;
                localStorage.setItem('openai_api_key', key);
                updateApiKeyUI();
                alert('API 키가 저장되었습니다.');
            } else {
                alert('유효한 API 키를 입력해주세요.');
            }
        }

        // 관리자 기능
        function showAdminLogin() {
            document.getElementById('adminLoginSection').classList.remove('hidden');
        }

        function hideAdminLogin() {
            document.getElementById('adminLoginSection').classList.add('hidden');
            document.getElementById('adminPasswordInput').value = '';
        }

        function adminLogin() {
            const password = document.getElementById('adminPasswordInput').value;
            if (password === ADMIN_PASSWORD) {
                isAdminLoggedIn = true;
                hideAdminLogin();
                showAdminPanel();
                loadProblemSetsManagement();
            } else {
                alert('비밀번호가 틀렸습니다.');
            }
        }

        function showAdminPanel() {
            document.getElementById('adminPanel').classList.remove('hidden');
        }

        function hideAdminPanel() {
            document.getElementById('adminPanel').classList.add('hidden');
            isAdminLoggedIn = false;
        }

        function showAddProblemSet() {
            editingProblemSetKey = null;
            document.getElementById('formTitle').textContent = '➕ 새 문제집 추가';
            document.getElementById('problemSetKey').value = '';
            document.getElementById('problemSetJSON').value = '';
            document.getElementById('saveBtn').textContent = '저장';
            document.getElementById('addProblemSetForm').classList.remove('hidden');
        }

        function hideAddProblemSetForm() {
            document.getElementById('addProblemSetForm').classList.add('hidden');
            editingProblemSetKey = null;
        }

        function showJSONExample() {
            const example = {
                "title": "예시 문제집",
                "description": "JSON 형식의 예시 문제집입니다",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "2 + 2 = ?",
                        "options": ["3", "4", "5", "6"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "2 + 2 = 4입니다."
                    }
                ]
            };
            document.getElementById('problemSetJSON').value = JSON.stringify(example, null, 2);
        }

        async function saveProblemSet() {
            const key = document.getElementById('problemSetKey').value.trim();
            const jsonText = document.getElementById('problemSetJSON').value.trim();

            if (!key) {
                alert('문제집 키를 입력해주세요.');
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(key)) {
                alert('문제집 키는 영문, 숫자, 언더스코어만 사용할 수 있습니다.');
                return;
            }

            if (!jsonText) {
                alert('JSON 데이터를 입력해주세요.');
                return;
            }

            try {
                const problemSet = JSON.parse(jsonText);
                
                // 기본 구조 검증
                if (!problemSet.title || !problemSet.description || !problemSet.questions) {
                    alert('JSON 형식이 올바르지 않습니다. title, description, questions 필드가 필요합니다.');
                    return;
                }

                // API에 저장
                if (editingProblemSetKey) {
                    // 편집 모드
                    await updateProblemSetInAPI(key, problemSet);
                    examData[key] = problemSet; // 로컬 캐시 업데이트
                } else {
                    // 새로 생성
                    await saveProblemSetToAPI(key, problemSet);
                    examData[key] = problemSet; // 로컬 캐시에 추가
                }

                alert('문제집이 저장되었습니다.');
                hideAddProblemSetForm();
                await loadProblemSetsIndex(); // 인덱스 새로고침
                await loadProblemSetsManagement();
                await loadExamList(); // 시험 목록 새로고침

            } catch (error) {
                if (error.message.includes('already exists')) {
                    alert('이미 존재하는 문제집 키입니다.');
                } else {
                    alert('문제집 저장 중 오류가 발생했습니다: ' + error.message);
                }
            }
        }

        function getCustomProblemSets() {
            // For backward compatibility, check localStorage
            const stored = localStorage.getItem('custom_problem_sets');
            return stored ? JSON.parse(stored) : {};
        }

        function getAllProblemSets() {
            return examData;
        }

        function editProblemSet(key) {
            const allSets = getAllProblemSets();
            const problemSet = allSets[key];
            
            if (!problemSet) {
                alert('문제집을 찾을 수 없습니다.');
                return;
            }

            editingProblemSetKey = key;
            document.getElementById('formTitle').textContent = '✏️ 문제집 편집';
            document.getElementById('problemSetKey').value = key;
            document.getElementById('problemSetJSON').value = JSON.stringify(problemSet, null, 2);
            document.getElementById('saveBtn').textContent = '수정 저장';
            document.getElementById('addProblemSetForm').classList.remove('hidden');
        }

        async function deleteProblemSet(key) {
            const problemSetInfo = problemSetsIndex.problem_sets.find(ps => ps.key === key);
            
            if (problemSetInfo && problemSetInfo.is_built_in) {
                alert('기본 문제집은 삭제할 수 없습니다.');
                return;
            }

            if (confirm(`'${key}' 문제집을 삭제하시겠습니까?`)) {
                try {
                    await deleteProblemSetFromAPI(key);
                    delete examData[key]; // 로컬 캐시에서 제거
                    
                    await loadProblemSetsIndex(); // 인덱스 새로고침
                    await loadProblemSetsManagement();
                    await loadExamList(); // 시험 목록 새로고침
                    alert('문제집이 삭제되었습니다.');
                } catch (error) {
                    alert('문제집 삭제 중 오류가 발생했습니다: ' + error.message);
                }
            }
        }

        async function loadProblemSetsManagement() {
            const container = document.getElementById('problemSetsManagement');
            container.innerHTML = '';
            
            if (!problemSetsIndex) {
                container.innerHTML = '<p>문제집 목록을 불러오는 중...</p>';
                return;
            }
            
            for (const problemSetInfo of problemSetsIndex.problem_sets) {
                const key = problemSetInfo.key;
                const exam = examData[key];
                
                if (!exam) {
                    // 아직 로드되지 않은 문제집은 로드
                    await loadProblemSet(key);
                }
                
                const setDiv = document.createElement('div');
                setDiv.style.cssText = 'border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; margin: 10px 0; background: #f8fafc;';
                
                const questionCount = examData[key] ? getTotalQuestionCount(examData[key].questions) : '?';
                
                setDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4>${problemSetInfo.title} ${problemSetInfo.is_built_in ? '(기본)' : '(커스텀)'}</h4>
                            <p style="color: #718096; margin: 5px 0;">${problemSetInfo.description}</p>
                            <small style="color: #a0aec0;">키: ${key} | 문제 수: ${questionCount}</small>
                        </div>
                        <div>
                            <button onclick="editProblemSet('${key}')" style="background: #4299e1; color: white; border: none; padding: 8px 12px; border-radius: 4px; margin: 0 5px; cursor: pointer;">편집</button>
                            ${!problemSetInfo.is_built_in ? `<button onclick="deleteProblemSet('${key}')" style="background: #e53e3e; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">삭제</button>` : ''}
                        </div>
                    </div>
                `;
                
                container.appendChild(setDiv);
            }
        }

        async function loadExamList() {
            const examGrid = document.getElementById('examGrid');
            examGrid.innerHTML = '';

            if (!problemSetsIndex || !problemSetsIndex.problem_sets) {
                console.log('Problem sets index not available, trying to reload...');
                
                // Try to reload the problem sets index
                try {
                    problemSetsIndex = await loadProblemSetsIndex();
                } catch (error) {
                    console.error('Failed to reload problem sets index:', error);
                    examGrid.innerHTML = '<p style="color: #e53e3e;">문제집을 불러오는데 실패했습니다. 새로고침해보세요.</p>';
                    return;
                }
                
                if (!problemSetsIndex || !problemSetsIndex.problem_sets) {
                    examGrid.innerHTML = '<p style="color: #e53e3e;">문제집 목록을 불러올 수 없습니다.</p>';
                    return;
                }
            }

            console.log('Loading exam list with', problemSetsIndex.problem_sets.length, 'problem sets');

            for (const problemSetInfo of problemSetsIndex.problem_sets) {
                const key = problemSetInfo.key;
                
                const examCard = document.createElement('div');
                examCard.className = 'exam-card';
                examCard.onclick = () => startExam(key);
                
                // 문제 개수 계산
                let questionCount = 0;
                if (examData[key]) {
                    questionCount = getTotalQuestionCount(examData[key].questions);
                }
                
                examCard.innerHTML = `
                    <h3>${problemSetInfo.title}</h3>
                    <p>${problemSetInfo.description}</p>
                    <p><strong>카테고리:</strong> ${problemSetInfo.category || 'general'}</p>
                    ${questionCount > 0 ? `<p><strong>문제 수:</strong> ${questionCount}개</p>` : ''}
                    <div style="margin-top: 15px; text-align: right;">
                        <button onclick="showProblemList('${key}')" style="background: #4299e1; color: white; border: none; padding: 8px 12px; border-radius: 4px; font-size: 0.85rem; margin-right: 8px;">📋 문제 목록</button>
                        <button onclick="copyProblemSetUrl('${key}'); event.stopPropagation();" style="background: #38a169; color: white; border: none; padding: 8px 12px; border-radius: 4px; font-size: 0.85rem;">🔗 URL 복사</button>
                    </div>
                `;
                
                examGrid.appendChild(examCard);
            }
        }

        function getTotalQuestionCount(questions) {
            let count = 0;
            questions.forEach(q => {
                if (q.type === 'compound') {
                    count += q.sub_questions.length;
                } else {
                    count += 1;
                }
            });
            return count;
        }

        function copyProblemSetUrl(problemSetKey) {
            const baseUrl = window.location.origin;
            const problemSetUrl = `${baseUrl}/exam/${problemSetKey}`;
            
            navigator.clipboard.writeText(problemSetUrl).then(() => {
                // 성공 메시지 표시
                const button = event.target;
                const originalText = button.innerHTML;
                button.innerHTML = '✅ 복사됨';
                button.style.background = '#38a169';
                
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.style.background = '#38a169';
                }, 2000);
            }).catch(err => {
                console.error('URL 복사 실패:', err);
                // 폴백: alert으로 URL 표시
                alert(`문제집 URL:\n${problemSetUrl}`);
            });
        }

        async function startExam(examKey) {
            // 문제집이 로드되지 않았다면 로드
            if (!examData[examKey]) {
                await loadProblemSet(examKey);
            }
            
            currentExam = examData[examKey];
            if (!currentExam) {
                alert('문제집을 불러올 수 없습니다.');
                return;
            }
            
            userAnswers = {};
            shuffledOptionsMap = {}; // 섞인 선택지 매핑 초기화
            
            document.getElementById('examSelector').classList.add('hidden');
            document.getElementById('examContainer').classList.remove('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            
            document.getElementById('examTitle').textContent = currentExam.title;
            document.getElementById('totalQuestions').textContent = getTotalQuestionCount(currentExam.questions);
            
            renderQuestions();
            updateProgress();
        }

        function renderQuestions() {
            const container = document.getElementById('questionContainer');
            container.innerHTML = '';
            
            let questionNumber = 1;
            
            currentExam.questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question-container';
                
                if (question.type === 'compound') {
                    questionDiv.innerHTML = `
                        <div class="question-header">
                            <span class="question-number">${questionNumber}</span>
                            <span class="question-score">${question.score}점</span>
                        </div>
                        <div class="question-text">${question.question}</div>
                        <div class="sub-questions">
                            ${question.sub_questions.map((subQ, subIndex) => {
                                const subQuestionHtml = renderSubQuestion(subQ, `${question.id}-${subIndex}`, questionNumber + subIndex);
                                return `<div class="sub-question">${subQuestionHtml}</div>`;
                            }).join('')}
                        </div>
                    `;
                    questionNumber += question.sub_questions.length;
                } else {
                    questionDiv.innerHTML = renderSingleQuestion(question, questionNumber);
                    questionNumber++;
                }
                
                container.appendChild(questionDiv);
            });
            
            setTimeout(renderMath, 100);
        }

        function renderSingleQuestion(question, questionNumber) {
            const questionId = question.id;
            
            let optionsHtml = '';
            
            switch (question.type) {
                case 'single_choice':
                    const shuffledSingleOptions = shuffleOptionsWithMapping(question.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSingleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="radio" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'multiple_choice':
                    const shuffledMultipleOptions = shuffleOptionsWithMapping(question.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledMultipleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="checkbox" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'true_false':
                    optionsHtml = `
                        <div class="options">
                            <div class="option">
                                <input type="radio" id="q${questionId}_true" name="q${questionId}" value="true">
                                <label for="q${questionId}_true">참</label>
                            </div>
                            <div class="option">
                                <input type="radio" id="q${questionId}_false" name="q${questionId}" value="false">
                                <label for="q${questionId}_false">거짓</label>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'short_answer':
                case 'essay':
                    optionsHtml = `
                        <textarea class="text-answer" id="q${questionId}" placeholder="답안을 입력하세요..."></textarea>
                    `;
                    break;
            }
            
            return `
                <div class="question-header">
                    <span class="question-number">${questionNumber}</span>
                    <span class="question-score">${question.score}점</span>
                </div>
                <div class="question-text">${question.question}</div>
                ${optionsHtml}
            `;
        }

        function renderSubQuestion(subQuestion, questionId, questionNumber) {
            let optionsHtml = '';
            
            switch (subQuestion.type) {
                case 'single_choice':
                    const shuffledSubSingleOptions = shuffleOptionsWithMapping(subQuestion.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSubSingleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="radio" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'multiple_choice':
                    const shuffledSubMultipleOptions = shuffleOptionsWithMapping(subQuestion.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSubMultipleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="checkbox" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'true_false':
                    optionsHtml = `
                        <div class="options">
                            <div class="option">
                                <input type="radio" id="q${questionId}_true" name="q${questionId}" value="true">
                                <label for="q${questionId}_true">참</label>
                            </div>
                            <div class="option">
                                <input type="radio" id="q${questionId}_false" name="q${questionId}" value="false">
                                <label for="q${questionId}_false">거짓</label>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'short_answer':
                case 'essay':
                    optionsHtml = `
                        <textarea class="text-answer" id="q${questionId}" placeholder="답안을 입력하세요..."></textarea>
                    `;
                    break;
            }
            
            return `
                <div class="question-header">
                    <span class="question-number">${questionNumber}</span>
                    <span class="question-score">${subQuestion.score}점</span>
                </div>
                <div class="question-text">${subQuestion.question}</div>
                ${optionsHtml}
            `;
        }

        function updateProgress() {
            document.getElementById('progressFill').style.width = '0%';
        }

        async function submitAnswers() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="loading"></span> 채점 중...';
            
            // 답안 수집
            collectAnswers();
            
            // 채점 수행
            const results = await gradeAnswers();
            
            // 결과 표시
            showResults(results);
            
            submitBtn.disabled = false;
            submitBtn.innerHTML = '답안 제출';
        }

        function collectAnswers() {
            userAnswers = {};
            
            currentExam.questions.forEach((question, index) => {
                if (question.type === 'compound') {
                    question.sub_questions.forEach((subQ, subIndex) => {
                        const questionId = `${question.id}-${subIndex}`;
                        userAnswers[questionId] = collectSingleAnswer(subQ, questionId);
                    });
                } else {
                    userAnswers[question.id] = collectSingleAnswer(question, question.id);
                }
            });
        }

        function collectSingleAnswer(question, questionId) {
            switch (question.type) {
                case 'single_choice':
                    const radio = document.querySelector(`input[name="q${questionId}"]:checked`);
                    if (radio) {
                        const shuffledIndex = parseInt(radio.value);
                        // 섞인 인덱스를 원본 인덱스로 변환
                        const mapping = shuffledOptionsMap[questionId];
                        return mapping ? mapping.shuffledToOriginal[shuffledIndex] : shuffledIndex;
                    }
                    return null;
                    
                case 'multiple_choice':
                    const checkboxes = document.querySelectorAll(`input[name="q${questionId}"]:checked`);
                    const shuffledIndices = Array.from(checkboxes).map(cb => parseInt(cb.value));
                    // 섞인 인덱스들을 원본 인덱스들로 변환
                    const mapping = shuffledOptionsMap[questionId];
                    if (mapping) {
                        return shuffledIndices.map(index => mapping.shuffledToOriginal[index]);
                    }
                    return shuffledIndices;
                    
                case 'true_false':
                    const tfRadio = document.querySelector(`input[name="q${questionId}"]:checked`);
                    return tfRadio ? tfRadio.value : null;
                    
                case 'short_answer':
                case 'essay':
                    const textarea = document.getElementById(`q${questionId}`);
                    return textarea ? textarea.value.trim() : '';
                    
                default:
                    return null;
            }
        }

        async function gradeAnswers() {
            const results = {};
            
            for (const question of currentExam.questions) {
                if (question.type === 'compound') {
                    for (let subIndex = 0; subIndex < question.sub_questions.length; subIndex++) {
                        const subQ = question.sub_questions[subIndex];
                        const questionId = `${question.id}-${subIndex}`;
                        const userAnswer = userAnswers[questionId];
                        
                        if (subQ.type === 'essay') {
                            results[questionId] = await gradeEssayWithAPI(subQ, userAnswer);
                        } else {
                            results[questionId] = gradeObjectiveQuestion(subQ, userAnswer);
                        }
                    }
                } else {
                    const questionId = question.id;
                    const userAnswer = userAnswers[questionId];
                    
                    if (question.type === 'essay') {
                        results[questionId] = await gradeEssayWithAPI(question, userAnswer);
                    } else {
                        results[questionId] = gradeObjectiveQuestion(question, userAnswer);
                    }
                }
            }
            
            return results;
        }

        function gradeObjectiveQuestion(question, userAnswer) {
            let isCorrect = false;
            let score = 0;
            
            switch (question.type) {
                case 'single_choice':
                    isCorrect = parseInt(userAnswer) === question.correct_answer;
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'multiple_choice':
                    const correctAnswers = question.correct_answers.sort();
                    const userAnswersSorted = (userAnswer || []).sort();
                    isCorrect = JSON.stringify(correctAnswers) === JSON.stringify(userAnswersSorted);
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'true_false':
                    const correctAnswer = question.correct_answer.toString();
                    isCorrect = userAnswer === correctAnswer;
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'short_answer':
                    isCorrect = userAnswer && userAnswer.toLowerCase() === question.correct_answer.toLowerCase();
                    score = isCorrect ? question.score : 0;
                    break;
            }
            
            return {
                isCorrect,
                score,
                maxScore: question.score,
                userAnswer,
                correctAnswer: question.correct_answer || question.correct_answers,
                explanation: question.explanation
            };
        }

        async function gradeEssayQuestion(question, userAnswer) {
            if (!apiKey) {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer,
                    explanation: question.explanation,
                    feedback: "API 키가 설정되지 않아 주관식 문제를 채점할 수 없습니다."
                };
            }

            if (!userAnswer || userAnswer.trim() === '') {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer: '',
                    explanation: question.explanation,
                    feedback: "답안이 입력되지 않았습니다."
                };
            }

            // 브라우저 제한으로 인해 직접 OpenAI API 호출이 어려우므로 
            // 임시로 간단한 키워드 기반 채점을 사용합니다.
            return gradeEssaySimple(question, userAnswer);
        }

        function gradeEssaySimple(question, userAnswer) {
            // 간단한 키워드 기반 채점 시스템
            const answerLower = userAnswer.toLowerCase();
            let score = 0;
            let feedback = "";
            
            // 기본 점수 (답안을 작성했으면 기본점수 부여)
            if (userAnswer.length > 10) {
                score = Math.floor(question.score * 0.3); // 30% 기본점수
                feedback = "답안을 성실히 작성했습니다. ";
            }
            
            // 문제별 키워드 채점
            if (question.question.includes("피타고라스")) {
                const keywords = ["a²+b²=c²", "a^2+b^2=c^2", "직각삼각형", "빗변", "제곱", "루트"];
                let keywordCount = 0;
                keywords.forEach(keyword => {
                    if (answerLower.includes(keyword.toLowerCase())) {
                        keywordCount++;
                    }
                });
                
                if (keywordCount >= 3) {
                    score = question.score; // 만점
                    feedback += "피타고라스 정리를 정확히 이해하고 계산을 올바르게 수행했습니다.";
                } else if (keywordCount >= 2) {
                    score = Math.floor(question.score * 0.7); // 70%
                    feedback += "피타고라스 정리의 개념은 이해했으나 설명이 부족합니다.";
                } else if (keywordCount >= 1) {
                    score = Math.floor(question.score * 0.5); // 50%
                    feedback += "피타고라스 정리에 대한 기본 이해는 있으나 더 자세한 설명이 필요합니다.";
                }
            }
            
            else if (question.question.includes("뉴턴") && question.question.includes("제3법칙")) {
                const keywords = ["작용", "반작용", "같은", "크기", "반대", "방향", "힘", "법칙"];
                let keywordCount = 0;
                keywords.forEach(keyword => {
                    if (answerLower.includes(keyword.toLowerCase())) {
                        keywordCount++;
                    }
                });
                
                if (keywordCount >= 4) {
                    score = question.score;
                    feedback += "뉴턴 제3법칙을 정확히 설명했습니다.";
                } else if (keywordCount >= 2) {
                    score = Math.floor(question.score * 0.7);
                    feedback += "뉴턴 제3법칙의 기본 개념은 맞으나 더 정확한 설명이 필요합니다.";
                }
            }
            
            // 답안 길이에 따른 추가 점수 조정
            if (userAnswer.length < 20) {
                score = Math.min(score, Math.floor(question.score * 0.4));
                feedback += " 답안이 너무 짧습니다.";
            } else if (userAnswer.length > 100) {
                feedback += " 상세한 답안을 작성했습니다.";
            }
            
            return {
                isCorrect: score === question.score,
                score: Math.min(score, question.score),
                maxScore: question.score,
                userAnswer,
                explanation: question.explanation,
                feedback: feedback || "답안을 검토해보세요."
            };
        }

        // 새로운 AI 채점 시스템을 사용하는 함수
        async function gradeEssayWithAPI(question, userAnswer) {
            try {
                console.log('🤖 Using new AI grading system...');
                
                if (!authToken) {
                    console.error('No auth token available');
                    return gradeEssayFallback(question, userAnswer);
                }
                
                const response = await fetch('/api/grade-essay', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        question: question,
                        userAnswer: userAnswer,
                        maxScore: question.score
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`AI grading API failed: ${response.status}`, errorText);
                    throw new Error(`API request failed: ${response.status}`);
                }

                const result = await response.json();
                console.log('✅ AI grading successful:', result.method);
                
                return {
                    isCorrect: result.isCorrect,
                    score: result.score,
                    maxScore: question.score,
                    userAnswer: userAnswer,
                    explanation: question.explanation,
                    feedback: result.feedback,
                    strengths: result.strengths,
                    improvements: result.improvements,
                    method: result.method,
                    timestamp: result.timestamp
                };
                
            } catch (error) {
                console.error('AI grading failed, using fallback:', error.message);
                // 실패시 개선된 fallback 채점으로 대체
                return gradeEssayFallback(question, userAnswer);
            }
        }
        
        // 개선된 fallback 채점 시스템
        function gradeEssayFallback(question, userAnswer) {
            console.log('📝 Using improved fallback grading...');
            
            const answerLower = userAnswer.toLowerCase();
            let score = 0;
            let feedback = "";
            let strengths = "";
            let improvements = "";
            
            // 답안이 너무 짧은 경우
            if (userAnswer.trim().length < 5) {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer: userAnswer,
                    explanation: question.explanation,
                    feedback: "답안이 너무 짧습니다. 문제에서 요구하는 내용을 자세히 작성해주세요.",
                    strengths: "문제에 응답하려는 의지를 보였습니다.",
                    improvements: "더 자세한 설명과 계산 과정을 포함해주세요.",
                    method: 'fallback'
                };
            }
            
            // 기본 노력 점수
            let baseScore = Math.floor(question.score * 0.4); // 40%
            
            // 수학적 표현 탐지
            const hasFormula = /(\d+\s*[\+\-\*\/\^²]\s*\d+)|([a-z]²?\s*[\+\-\*\/]\s*[a-z]²?)|(=\s*\d+)/.test(answerLower);
            const hasCalculation = /\d+/.test(userAnswer);
            
            // 피타고라스 정리 문제 특별 처리
            if (question.question.includes("피타고라스") || question.question.includes("pythagorean")) {
                // 정확한 계산 확인 (5² - 3² = 16, 답 = 4)
                const hasCorrectCalculation = 
                    (answerLower.includes("25") && answerLower.includes("9") && answerLower.includes("16")) ||
                    (answerLower.includes("5²") && answerLower.includes("3²")) ||
                    (answerLower.includes("5^2") && answerLower.includes("3^2")) ||
                    (answerLower.includes("4²") || answerLower.includes("= 4") || answerLower.includes("답은 4") || answerLower.includes("정답은 4"));
                
                if (hasCorrectCalculation) {
                    score = Math.floor(question.score * 0.85); // 85% 정확한 계산
                    feedback = "수학적 계산이 정확합니다! ";
                    strengths = "피타고라스 정리를 올바르게 적용하여 정확한 답을 도출했습니다.";
                    improvements = "피타고라스 정리의 개념 설명을 추가하면 더 완벽한 답안이 됩니다.";
                } else if (hasFormula && hasCalculation) {
                    score = Math.floor(question.score * 0.6); // 60%
                    feedback = "수학적 접근을 시도했습니다. ";
                    strengths = "공식을 사용하려고 노력했습니다.";
                    improvements = "계산 과정을 더 정확하게 확인해보세요.";
                } else if (hasCalculation) {
                    score = Math.floor(question.score * 0.5); // 50%
                    feedback = "계산을 시도했습니다. ";
                    strengths = "수치적 접근을 시도했습니다.";
                    improvements = "피타고라스 정리 공식(a²+b²=c²)을 활용해보세요.";
                } else {
                    score = baseScore;
                    feedback = "답안을 작성했으나 계산이 부족합니다. ";
                    strengths = "문제에 응답하려고 노력했습니다.";
                    improvements = "수치 계산과 공식 적용을 포함해주세요.";
                }
            } else {
                // 일반 서술형 문제
                if (userAnswer.length > 100) {
                    score = Math.floor(question.score * 0.7);
                    feedback = "자세한 답안을 작성했습니다. ";
                } else if (userAnswer.length > 50) {
                    score = Math.floor(question.score * 0.6);
                    feedback = "적절한 길이의 답안을 작성했습니다. ";
                } else {
                    score = baseScore;
                    feedback = "답안이 다소 짧습니다. ";
                }
                
                strengths = "문제에 성실히 응답했습니다.";
                improvements = "더 구체적인 설명과 예시를 포함하면 좋겠습니다.";
            }
            
            return {
                isCorrect: score >= question.score * 0.7,
                score: Math.min(score, question.score),
                maxScore: question.score,
                userAnswer: userAnswer,
                explanation: question.explanation,
                feedback: feedback + "(개선된 기본 채점 시스템 사용)",
                strengths: strengths,
                improvements: improvements,
                method: 'fallback'
            };
        }

        function showResults(results) {
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.remove('hidden');
            
            let totalScore = 0;
            let maxTotalScore = 0;
            
            // 점수 계산
            for (const result of Object.values(results)) {
                totalScore += result.score;
                maxTotalScore += result.maxScore;
            }
            
            // 점수 표시
            const percentage = Math.round((totalScore / maxTotalScore) * 100);
            document.getElementById('finalScore').textContent = `${totalScore}/${maxTotalScore}점 (${percentage}%)`;
            
            let scoreDescription = '';
            if (percentage >= 90) {
                scoreDescription = '🎉 훌륭합니다! 매우 우수한 성적입니다.';
            } else if (percentage >= 80) {
                scoreDescription = '👏 잘했습니다! 좋은 성적입니다.';
            } else if (percentage >= 70) {
                scoreDescription = '👍 괜찮습니다! 조금만 더 노력하면 됩니다.';
            } else if (percentage >= 60) {
                scoreDescription = '📚 더 공부가 필요합니다.';
            } else {
                scoreDescription = '💪 포기하지 말고 다시 도전해보세요!';
            }
            document.getElementById('scoreDescription').textContent = scoreDescription;
            
            // 답안 검토 표시
            const reviewsContainer = document.getElementById('answerReviews');
            reviewsContainer.innerHTML = '';
            
            let questionNumber = 1;
            
            currentExam.questions.forEach((question) => {
                if (question.type === 'compound') {
                    const compoundDiv = document.createElement('div');
                    compoundDiv.innerHTML = `<h3>${question.question}</h3>`;
                    
                    question.sub_questions.forEach((subQ, subIndex) => {
                        const questionId = `${question.id}-${subIndex}`;
                        const result = results[questionId];
                        
                        const reviewDiv = createAnswerReview(subQ, result, questionNumber);
                        
                        // 개별 문제 링크 추가
                        const linkDiv = document.createElement('div');
                        linkDiv.style.cssText = 'margin: 10px 0; text-align: right;';
                        linkDiv.innerHTML = `
                            <button class="btn" onclick="navigateToProblem('${currentExam.key || Object.keys(examData).find(key => examData[key] === currentExam)}', ${question.id})" 
                                    style="background: #4299e1; font-size: 0.8rem; padding: 5px 10px;">
                                🔗 이 문제만 보기
                            </button>
                        `;
                        reviewDiv.appendChild(linkDiv);
                        
                        compoundDiv.appendChild(reviewDiv);
                        questionNumber++;
                    });
                    
                    reviewsContainer.appendChild(compoundDiv);
                } else {
                    const result = results[question.id];
                    const reviewDiv = createAnswerReview(question, result, questionNumber);
                    
                    // 개별 문제 링크 추가
                    const linkDiv = document.createElement('div');
                    linkDiv.style.cssText = 'margin: 10px 0; text-align: right;';
                    linkDiv.innerHTML = `
                        <button class="btn" onclick="navigateToProblem('${currentExam.key || Object.keys(examData).find(key => examData[key] === currentExam)}', ${question.id})" 
                                style="background: #4299e1; font-size: 0.8rem; padding: 5px 10px;">
                            🔗 이 문제만 보기
                        </button>
                    `;
                    reviewDiv.appendChild(linkDiv);
                    
                    reviewsContainer.appendChild(reviewDiv);
                    questionNumber++;
                }
            });
            
            setTimeout(renderMath, 100);
        }

        function createAnswerReview(question, result, questionNumber) {
            const reviewDiv = document.createElement('div');
            
            let statusClass = 'incorrect';
            let statusText = '틀림';
            
            if (result.isCorrect) {
                statusClass = 'correct';
                statusText = '정답';
            } else if (result.score > 0) {
                statusClass = 'partial';
                statusText = '부분 정답';
            }
            
            reviewDiv.className = `answer-review ${statusClass}`;
            
            let userAnswerText = '';
            if (question.type === 'multiple_choice') {
                const selectedOptions = (result.userAnswer || []).map(index => question.options[index]);
                userAnswerText = selectedOptions.length > 0 ? selectedOptions.join(', ') : '선택하지 않음';
            } else if (question.type === 'single_choice') {
                userAnswerText = result.userAnswer !== null ? question.options[result.userAnswer] : '선택하지 않음';
            } else if (question.type === 'true_false') {
                userAnswerText = result.userAnswer === 'true' ? '참' : result.userAnswer === 'false' ? '거짓' : '선택하지 않음';
            } else {
                userAnswerText = result.userAnswer || '답안 없음';
            }
            
            let correctAnswerText = '';
            if (question.type === 'multiple_choice') {
                correctAnswerText = question.correct_answers.map(index => question.options[index]).join(', ');
            } else if (question.type === 'single_choice') {
                correctAnswerText = question.options[question.correct_answer];
            } else if (question.type === 'true_false') {
                correctAnswerText = question.correct_answer ? '참' : '거짓';
            } else if (question.type === 'short_answer') {
                correctAnswerText = question.correct_answer;
            } else {
                correctAnswerText = '주관식 문제';
            }
            
            // 채점 방법 표시 (AI vs Fallback)
            let gradingMethodBadge = '';
            if (result.method === 'ai') {
                gradingMethodBadge = '<span class="method-badge ai">🤖 AI 채점</span>';
            } else if (result.method === 'fallback') {
                gradingMethodBadge = '<span class="method-badge fallback">📝 기본 채점</span>';
            }
            
            reviewDiv.innerHTML = `
                <div class="status-badge ${statusClass}">${statusText} (${result.score}/${result.maxScore}점) ${gradingMethodBadge}</div>
                <h4>문제 ${questionNumber}: ${question.question}</h4>
                <p><strong>내 답안:</strong> ${userAnswerText}</p>
                ${question.type !== 'essay' ? `<p><strong>정답:</strong> ${correctAnswerText}</p>` : ''}
                ${result.feedback ? `
                    <div class="ai-feedback">
                        <strong>📝 종합 피드백:</strong>
                        <p>${result.feedback}</p>
                    </div>
                ` : ''}
                ${result.strengths ? `
                    <div class="feedback-strengths">
                        <strong>✅ 잘한 점:</strong>
                        <p>${result.strengths}</p>
                    </div>
                ` : ''}
                ${result.improvements ? `
                    <div class="feedback-improvements">
                        <strong>💡 개선 사항:</strong>
                        <p>${result.improvements}</p>
                    </div>
                ` : ''}
                <div class="explanation">
                    <strong>📚 해설:</strong> ${result.explanation}
                </div>
                ${result.timestamp ? `
                    <div class="grading-info">
                        <small>채점 시간: ${new Date(result.timestamp).toLocaleString('ko-KR')}</small>
                    </div>
                ` : ''}
            `;
            
            return reviewDiv;
        }

        async function showProblemList(problemSetKey) {
            // 문제집 로드
            if (!examData[problemSetKey]) {
                await loadProblemSet(problemSetKey);
            }
            
            const problemSet = examData[problemSetKey];
            if (!problemSet) {
                alert('문제집을 찾을 수 없습니다.');
                return;
            }

            // 기존 화면 숨기기
            document.getElementById('examSelector').classList.add('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            document.getElementById('singleProblemContainer').classList.add('hidden');
            
            // 문제 목록 컨테이너 생성 또는 표시
            let listContainer = document.getElementById('problemListContainer');
            if (!listContainer) {
                listContainer = document.createElement('div');
                listContainer.id = 'problemListContainer';
                listContainer.className = 'card hidden';
                document.querySelector('.container').appendChild(listContainer);
            }
            
            listContainer.classList.remove('hidden');
            
            // 헤더 생성
            const header = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <div>
                        <h2>${problemSet.title} - 문제 목록</h2>
                        <p>${problemSet.description}</p>
                    </div>
                    <div>
                        <button class="btn" onclick="navigateToHome()" style="background: #718096;">목록으로</button>
                        <button class="btn" onclick="startExam('${problemSetKey}')" style="background: #38a169;">전체 시험 시작</button>
                    </div>
                </div>
            `;
            
            // 문제 목록 생성
            let problemListHtml = '';
            let questionNumber = 1;
            
            problemSet.questions.forEach((question) => {
                if (question.type === 'compound') {
                    problemListHtml += `
                        <div class="question-container" style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1;">
                                    <h4>문제 ${questionNumber}: ${question.question.substring(0, 100)}${question.question.length > 100 ? '...' : ''}</h4>
                                    <p style="color: #718096; margin: 5px 0;">복합 문제 (${question.sub_questions.length}개 하위 문제) | ${question.score}점</p>
                                </div>
                                <div>
                                    <button class="btn" onclick="navigateToProblem('${problemSetKey}', ${question.id})" 
                                            style="background: #4299e1; font-size: 0.9rem; padding: 8px 16px;">
                                        📝 풀어보기
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                    questionNumber += question.sub_questions.length;
                } else {
                    const typeText = {
                        'single_choice': '객관식(단일선택)',
                        'multiple_choice': '객관식(다중선택)', 
                        'true_false': 'O/X',
                        'short_answer': '단답형',
                        'essay': '서술형'
                    }[question.type] || question.type;
                    
                    problemListHtml += `
                        <div class="question-container" style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1;">
                                    <h4>문제 ${questionNumber}: ${question.question.substring(0, 100)}${question.question.length > 100 ? '...' : ''}</h4>
                                    <p style="color: #718096; margin: 5px 0;">${typeText} | ${question.score}점</p>
                                </div>
                                <div>
                                    <button class="btn" onclick="navigateToProblem('${problemSetKey}', ${question.id})" 
                                            style="background: #4299e1; font-size: 0.9rem; padding: 8px 16px;">
                                        📝 풀어보기
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                    questionNumber++;
                }
            });
            
            listContainer.innerHTML = `
                ${header}
                <div style="border-top: 2px solid #e2e8f0; padding-top: 20px;">
                    ${problemListHtml}
                </div>
            `;
            
            setTimeout(renderMath, 100);
        }

        function resetExam() {
            currentExam = null;
            userAnswers = {};
            shuffledOptionsMap = {}; // 섞인 선택지 매핑 초기화
            
            document.getElementById('examSelector').classList.remove('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            document.getElementById('singleProblemContainer').classList.add('hidden');
            document.getElementById('problemListContainer').classList.add('hidden');
        }
    </script>
</body>
</html>
