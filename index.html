<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>시험 문제 연습 서비스</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .exam-selector {
            margin-bottom: 30px;
        }

        .exam-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .exam-card {
            background: linear-gradient(145deg, #f0f4f8, #e2e8f0);
            border: none;
            border-radius: 12px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .exam-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            background: linear-gradient(145deg, #e2e8f0, #cbd5e0);
        }

        .exam-card h3 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .exam-card p {
            color: #718096;
            font-size: 0.95rem;
        }

        .question-container {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8fafc;
            border-radius: 12px;
            border-left: 5px solid #667eea;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .question-score {
            background: #38a169;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
            line-height: 1.7;
        }

        .sub-questions {
            margin-left: 20px;
            border-left: 3px solid #e2e8f0;
            padding-left: 20px;
        }

        .sub-question {
            margin-bottom: 20px;
        }

        .options {
            margin: 15px 0;
        }

        .option {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }

        .option:hover {
            background-color: #f1f5f9;
        }

        .option input {
            margin-right: 12px;
            transform: scale(1.2);
        }

        .option label {
            cursor: pointer;
            flex: 1;
        }

        .text-answer {
            width: 100%;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
            resize: vertical;
            min-height: 100px;
        }

        .text-answer:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-container {
            margin-top: 30px;
        }

        .score-display {
            text-align: center;
            padding: 30px;
            background: linear-gradient(145deg, #48bb78, #38a169);
            color: white;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .score-display h2 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .answer-review {
            margin-bottom: 25px;
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #cbd5e0;
        }

        .answer-review.correct {
            background: #f0fff4;
            border-left-color: #48bb78;
        }

        .answer-review.incorrect {
            background: #fff5f5;
            border-left-color: #f56565;
        }

        .answer-review.partial {
            background: #fffbf0;
            border-left-color: #ed8936;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status-badge.correct {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-badge.incorrect {
            background: #fed7d7;
            color: #742a2a;
        }

        .status-badge.partial {
            background: #feebc8;
            color: #744210;
        }

        .explanation {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #667eea;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        .api-key-input {
            margin-bottom: 20px;
            padding: 20px;
            background: #f0f4f8;
            border-radius: 10px;
        }

        .api-key-input input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .card {
                padding: 20px;
            }
            
            .question-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📚 시험 문제 연습 서비스</h1>
            <p>다양한 유형의 문제를 풀고 실력을 향상시켜보세요!</p>
        </div>

        <!-- 전역 비밀번호 보호 화면 -->
        <div class="card" id="globalPasswordSection">
            <div style="text-align: center; padding: 40px 20px;">
                <h2>🔐 서비스 접속</h2>
                <p style="margin: 20px 0; color: #718096;">이 서비스는 비밀번호로 보호되고 있습니다.</p>
                <div style="max-width: 300px; margin: 0 auto;">
                    <input type="password" id="globalPasswordInput" placeholder="접속 비밀번호를 입력하세요" 
                           style="width: 100%; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; margin-bottom: 15px; text-align: center;">
                    <button class="btn" onclick="checkGlobalPassword()" style="width: 100%;">🚀 접속하기</button>
                    <div id="globalPasswordError" style="color: #e53e3e; margin-top: 10px; font-size: 0.9rem; display: none;">
                        ❌ 비밀번호가 올바르지 않습니다.
                    </div>
                </div>
            </div>
        </div>

        <!-- 메인 서비스 컨테이너 (비밀번호 확인 후 표시) -->
        <div id="mainServiceContainer" class="hidden">

        <!-- API Key 설정 -->
        <div class="card api-key-input" id="apiKeySection">
            <h3>🔑 OpenAI API 키 설정</h3>
            <p>주관식 문제 채점을 위해 OpenAI API 키가 필요합니다.</p>
            <input type="password" id="apiKeyInput" placeholder="OpenAI API 키를 입력하세요">
            <button class="btn" onclick="saveApiKey()">저장</button>
            <button class="btn" onclick="showAdminLogin()" style="float: right; background: linear-gradient(145deg, #e53e3e, #c53030);">🔧 관리자</button>
        </div>

        <!-- 관리자 로그인 -->
        <div class="card hidden" id="adminLoginSection">
            <h3>🔐 관리자 로그인</h3>
            <p>문제집 관리를 위해 관리자 비밀번호를 입력하세요.</p>
            <input type="password" id="adminPasswordInput" placeholder="관리자 비밀번호">
            <button class="btn" onclick="adminLogin()">로그인</button>
            <button class="btn" onclick="hideAdminLogin()" style="background: #718096;">취소</button>
        </div>

        <!-- 관리자 패널 -->
        <div class="card hidden" id="adminPanel">
            <h2>🛠️ 관리자 패널</h2>
            <div style="margin-bottom: 20px;">
                <button class="btn" onclick="showAddProblemSet()">➕ 문제집 추가</button>
                <button class="btn" onclick="hideAdminPanel()" style="background: #718096;">나가기</button>
            </div>
            
            <!-- 문제집 목록 -->
            <div id="adminProblemSetsList">
                <h3>📚 저장된 문제집</h3>
                <div id="problemSetsManagement"></div>
            </div>
        </div>

        <!-- 문제집 추가/편집 폼 -->
        <div class="card hidden" id="addProblemSetForm">
            <h3 id="formTitle">➕ 새 문제집 추가</h3>
            <div style="margin-bottom: 15px;">
                <label for="problemSetKey">문제집 키 (영문, 숫자, 언더스코어만):</label>
                <input type="text" id="problemSetKey" placeholder="예: custom_math_1" style="width: 100%; padding: 10px; margin-top: 5px; border: 2px solid #e2e8f0; border-radius: 8px;">
            </div>
            <div style="margin-bottom: 15px;">
                <label for="problemSetJSON">JSON 데이터:</label>
                <textarea id="problemSetJSON" rows="20" placeholder='JSON 형식으로 문제집을 입력하세요...' style="width: 100%; padding: 15px; border: 2px solid #e2e8f0; border-radius: 8px; font-family: monospace; font-size: 0.9rem;"></textarea>
            </div>
            <div>
                <button class="btn" onclick="saveProblemSet()" id="saveBtn">저장</button>
                <button class="btn" onclick="hideAddProblemSetForm()" style="background: #718096;">취소</button>
                <button class="btn" onclick="showJSONExample()" style="background: #38a169;">📄 예시 보기</button>
            </div>
        </div>

        <!-- 시험 선택 화면 -->
        <div class="card exam-selector" id="examSelector">
            <h2>📋 시험 선택</h2>
            <div class="exam-grid" id="examGrid">
                <!-- 시험 목록이 여기에 동적으로 생성됩니다 -->
            </div>
        </div>

        <!-- 문제 풀이 화면 -->
        <div class="card hidden" id="examContainer">
            <div id="examHeader">
                <h2 id="examTitle"></h2>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p>문제 <span id="currentQuestion">1</span> / <span id="totalQuestions">10</span></p>
            </div>
            
            <div id="questionContainer">
                <!-- 문제들이 여기에 동적으로 생성됩니다 -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="submitAnswers()" id="submitBtn">답안 제출</button>
                <button class="btn" onclick="resetExam()">처음으로</button>
            </div>
        </div>

        <!-- 결과 화면 -->
        <div class="card hidden" id="resultsContainer">
            <div class="score-display" id="scoreDisplay">
                <h2 id="finalScore"></h2>
                <p id="scoreDescription"></p>
            </div>
            
            <div id="answerReviews">
                <!-- 답안 검토가 여기에 표시됩니다 -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="resetExam()">다시 시작</button>
            </div>
        </div>

        </div> <!-- End of mainServiceContainer -->
    </div>

    <script>
        // API 설정
        const API_BASE_URL = window.location.hostname === 'localhost' ? '' : '';
        
        // 문제집 데이터 저장소
        let examData = {};
        let problemSetsIndex = null;

        let currentExam = null;
        let userAnswers = {};
        let apiKey = '';
        let isAdminLoggedIn = false;
        let editingProblemSetKey = null;
        let ADMIN_PASSWORD = 'admin123'; // 기본값, 환경변수로 덮어쓰기 가능
        let GLOBAL_PASSWORD = ''; // 전역 접속 비밀번호
        let isGloballyAuthenticated = false;
        let authToken = null; // API 인증 토큰
        let shuffledOptionsMap = {}; // 섞인 선택지의 매핑을 저장
        
        // 전역 비밀번호 확인 함수
        async function checkGlobalPassword() {
            const inputPassword = document.getElementById('globalPasswordInput').value.trim();
            const errorDiv = document.getElementById('globalPasswordError');
            
            if (!inputPassword) {
                showPasswordError('비밀번호를 입력해주세요.');
                return;
            }

            try {
                // 서버에서 인증 시도
                const authResult = await apiCall('auth', {
                    method: 'POST',
                    body: JSON.stringify({ password: inputPassword })
                });

                if (authResult.success) {
                    authToken = authResult.token;
                    isGloballyAuthenticated = true;
                    
                    // 인증 성공 시 메인 서비스 로드
                    await initializeMainService();
                    
                    // UI 전환
                    document.getElementById('globalPasswordSection').classList.add('hidden');
                    document.getElementById('mainServiceContainer').classList.remove('hidden');
                    
                    // 비밀번호 입력창 초기화
                    document.getElementById('globalPasswordInput').value = '';
                    errorDiv.style.display = 'none';
                    
                } else {
                    showPasswordError('비밀번호가 올바르지 않습니다.');
                }
            } catch (error) {
                console.error('Authentication failed:', error);
                showPasswordError('인증 중 오류가 발생했습니다.');
            }
        }

        function showPasswordError(message) {
            const errorDiv = document.getElementById('globalPasswordError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            // 3초 후 에러 메시지 숨기기
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 3000);
        }

        // 메인 서비스 초기화
        async function initializeMainService() {
            await loadEnvironmentVariables();
            updateApiKeyUI();
            await loadProblemSetsIndex();
            await loadExamList();
            renderMath();
        }

        // 환경변수 로드 함수
        async function loadEnvironmentVariables() {
            try {
                // 서버에서 환경변수 로드 (인증 토큰 포함)
                const config = await apiCall('config', {
                    headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {}
                });
                
                if (config.openaiApiKey) {
                    apiKey = config.openaiApiKey;
                    console.log('OpenAI API Key loaded from server environment variables');
                }
                
                if (config.adminPassword) {
                    ADMIN_PASSWORD = config.adminPassword;
                }
                
                if (config.globalPassword) {
                    GLOBAL_PASSWORD = config.globalPassword;
                }
                
            } catch (error) {
                console.error('Failed to load server configuration:', error);
                // Fallback to localStorage
                apiKey = localStorage.getItem('openai_api_key') || '';
            }
            
            // localStorage에서 사용자가 입력한 키가 있으면 우선 사용
            const storedApiKey = localStorage.getItem('openai_api_key');
            if (storedApiKey) {
                apiKey = storedApiKey;
                console.log('Using API key from localStorage (user override)');
            }
        }
        

        // 배열 섞기 함수 (Fisher-Yates shuffle)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // 선택지 섞기 및 매핑 생성
        function shuffleOptionsWithMapping(options, questionId) {
            const indexedOptions = options.map((option, index) => ({ option, originalIndex: index }));
            const shuffled = shuffleArray(indexedOptions);
            
            // 원본 인덱스 -> 섞인 인덱스 매핑
            const originalToShuffled = {};
            // 섞인 인덱스 -> 원본 인덱스 매핑
            const shuffledToOriginal = {};
            
            shuffled.forEach((item, newIndex) => {
                originalToShuffled[item.originalIndex] = newIndex;
                shuffledToOriginal[newIndex] = item.originalIndex;
            });
            
            shuffledOptionsMap[questionId] = {
                originalToShuffled,
                shuffledToOriginal,
                shuffledOptions: shuffled.map(item => item.option)
            };
            
            return shuffled.map(item => item.option);
        }

        // API 함수들
        async function apiCall(endpoint, options = {}) {
            try {
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                // 인증된 경우 토큰 추가 (auth 엔드포인트 제외)
                if (authToken && endpoint !== 'auth') {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE_URL}/api/${endpoint}`, {
                    headers,
                    ...options
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        async function loadProblemSetsIndex() {
            try {
                if (!authToken) {
                    console.error('No auth token available for API call');
                    return loadFallbackData();
                }
                
                problemSetsIndex = await apiCall('problem-sets');
                console.log('Problem sets index loaded successfully:', problemSetsIndex);
                return problemSetsIndex;
            } catch (error) {
                console.error('Failed to load problem sets index:', error);
                // Fallback to built-in data
                return loadFallbackData();
            }
        }

        async function loadProblemSet(key) {
            try {
                const problemSet = await apiCall(`problem-sets?key=${key}`);
                examData[key] = problemSet;
                return problemSet;
            } catch (error) {
                console.error(`Failed to load problem set ${key}:`, error);
                return null;
            }
        }

        async function saveProblemSetToAPI(key, data) {
            try {
                await apiCall('problem-sets', {
                    method: 'POST',
                    body: JSON.stringify({ key, data })
                });
                return true;
            } catch (error) {
                console.error('Failed to save problem set:', error);
                throw error;
            }
        }

        async function updateProblemSetInAPI(key, data) {
            try {
                await apiCall(`problem-sets?key=${key}`, {
                    method: 'PUT',
                    body: JSON.stringify({ data })
                });
                return true;
            } catch (error) {
                console.error('Failed to update problem set:', error);
                throw error;
            }
        }

        async function deleteProblemSetFromAPI(key) {
            try {
                await apiCall(`problem-sets?key=${key}`, {
                    method: 'DELETE'
                });
                return true;
            } catch (error) {
                console.error('Failed to delete problem set:', error);
                throw error;
            }
        }

        // Fallback 데이터 (API 실패 시 사용)
        function loadFallbackData() {
            console.log('Using fallback data due to API failure');
            
            // 기본 문제집 데이터를 직접 로드
            const fallbackMathData = {
                "title": "기초 수학",
                "description": "기본적인 수학 개념을 다루는 문제들",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "다음 중 $\\sqrt{16}$의 값은?",
                        "options": ["2", "4", "8", "16"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "$\\sqrt{16} = 4$입니다. 16의 제곱근은 4입니다."
                    },
                    {
                        "id": 2,
                        "type": "multiple_choice",
                        "question": "다음 중 소수인 것을 모두 고르세요.",
                        "options": ["2", "3", "4", "5", "6", "7"],
                        "correct_answers": [0, 1, 3, 5],
                        "score": 15,
                        "explanation": "소수는 1과 자기 자신으로만 나누어지는 자연수입니다. 2, 3, 5, 7이 소수입니다."
                    },
                    {
                        "id": 3,
                        "type": "true_false",
                        "question": "$\\pi$는 무리수이다.",
                        "correct_answer": true,
                        "score": 10,
                        "explanation": "$\\pi$는 무리수입니다. 유한소수나 순환소수로 표현할 수 없습니다."
                    }
                ]
            };
            
            const fallbackPhysicsData = {
                "title": "기초 물리학",
                "description": "물리학의 기본 개념과 공식들",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "자유낙하하는 물체의 가속도는 대략 얼마인가?",
                        "options": ["$9.8 \\text{ m/s}$", "$9.8 \\text{ m/s}^2$", "$98 \\text{ m/s}^2$", "$0.98 \\text{ m/s}^2$"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "지구에서 중력가속도는 약 $9.8 \\text{ m/s}^2$입니다."
                    }
                ]
            };
            
            // examData에 fallback 데이터 로드
            examData['math_basic'] = fallbackMathData;
            examData['physics_basic'] = fallbackPhysicsData;
            
            return {
                version: "1.0.0",
                problem_sets: [
                    {
                        key: "math_basic",
                        title: "기초 수학",
                        description: "기본적인 수학 개념을 다루는 문제들",
                        category: "mathematics",
                        is_built_in: true
                    },
                    {
                        key: "physics_basic",
                        title: "기초 물리학", 
                        description: "물리학의 기본 개념과 공식들",
                        category: "physics",
                        is_built_in: true
                    }
                ]
            };
        }

        // 초기화
        document.addEventListener('DOMContentLoaded', async function() {
            // 전역 비밀번호 보호가 활성화된 경우 로그인 화면 표시
            // 개발 환경에서는 바로 메인 서비스 로드 (필요시 주석 해제)
            // if (window.location.hostname === 'localhost') {
            //     await initializeMainService();
            //     document.getElementById('globalPasswordSection').classList.add('hidden');
            //     document.getElementById('mainServiceContainer').classList.remove('hidden');
            // }
            
            // Enter 키 지원
            document.getElementById('globalPasswordInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    checkGlobalPassword();
                }
            });
        });
        
        // API 키 UI 업데이트
        function updateApiKeyUI() {
            const apiKeyInput = document.getElementById('apiKeyInput');
            const apiKeySection = document.getElementById('apiKeySection');
            
            if (apiKey) {
                apiKeyInput.value = '***API키가 설정되었습니다***';
                apiKeyInput.disabled = true;
                
                // 환경변수에서 로드된 경우 알림 표시
                const envSource = document.createElement('p');
                envSource.style.cssText = 'color: #38a169; font-size: 0.9rem; margin-top: 5px;';
                envSource.innerHTML = '✅ API 키가 환경변수에서 자동으로 로드되었습니다.';
                
                if (!document.querySelector('.env-source-notice')) {
                    envSource.className = 'env-source-notice';
                    apiKeySection.appendChild(envSource);
                }
            } else {
                // 환경변수에서 로드되지 않은 경우 사용자 입력 허용
                const notice = document.createElement('p');
                notice.style.cssText = 'color: #e53e3e; font-size: 0.9rem; margin-top: 5px;';
                notice.innerHTML = '⚠️ 환경변수에서 API 키를 찾을 수 없습니다. 직접 입력해주세요.';
                notice.className = 'env-source-notice';
                apiKeySection.appendChild(notice);
            }
        }

        function renderMath() {
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ]
                });
            }
        }

        function saveApiKey() {
            const inputElement = document.getElementById('apiKeyInput');
            const key = inputElement.value.trim();
            
            // 환경변수로 이미 설정된 경우 사용자 입력 무시
            if (inputElement.disabled) {
                alert('API 키가 이미 환경변수에서 설정되었습니다.');
                return;
            }
            
            if (key && key !== '***API키가 설정되었습니다***') {
                apiKey = key;
                localStorage.setItem('openai_api_key', key);
                updateApiKeyUI();
                alert('API 키가 저장되었습니다.');
            } else {
                alert('유효한 API 키를 입력해주세요.');
            }
        }

        // 관리자 기능
        function showAdminLogin() {
            document.getElementById('adminLoginSection').classList.remove('hidden');
        }

        function hideAdminLogin() {
            document.getElementById('adminLoginSection').classList.add('hidden');
            document.getElementById('adminPasswordInput').value = '';
        }

        function adminLogin() {
            const password = document.getElementById('adminPasswordInput').value;
            if (password === ADMIN_PASSWORD) {
                isAdminLoggedIn = true;
                hideAdminLogin();
                showAdminPanel();
                loadProblemSetsManagement();
            } else {
                alert('비밀번호가 틀렸습니다.');
            }
        }

        function showAdminPanel() {
            document.getElementById('adminPanel').classList.remove('hidden');
        }

        function hideAdminPanel() {
            document.getElementById('adminPanel').classList.add('hidden');
            isAdminLoggedIn = false;
        }

        function showAddProblemSet() {
            editingProblemSetKey = null;
            document.getElementById('formTitle').textContent = '➕ 새 문제집 추가';
            document.getElementById('problemSetKey').value = '';
            document.getElementById('problemSetJSON').value = '';
            document.getElementById('saveBtn').textContent = '저장';
            document.getElementById('addProblemSetForm').classList.remove('hidden');
        }

        function hideAddProblemSetForm() {
            document.getElementById('addProblemSetForm').classList.add('hidden');
            editingProblemSetKey = null;
        }

        function showJSONExample() {
            const example = {
                "title": "예시 문제집",
                "description": "JSON 형식의 예시 문제집입니다",
                "questions": [
                    {
                        "id": 1,
                        "type": "single_choice",
                        "question": "2 + 2 = ?",
                        "options": ["3", "4", "5", "6"],
                        "correct_answer": 1,
                        "score": 10,
                        "explanation": "2 + 2 = 4입니다."
                    }
                ]
            };
            document.getElementById('problemSetJSON').value = JSON.stringify(example, null, 2);
        }

        async function saveProblemSet() {
            const key = document.getElementById('problemSetKey').value.trim();
            const jsonText = document.getElementById('problemSetJSON').value.trim();

            if (!key) {
                alert('문제집 키를 입력해주세요.');
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(key)) {
                alert('문제집 키는 영문, 숫자, 언더스코어만 사용할 수 있습니다.');
                return;
            }

            if (!jsonText) {
                alert('JSON 데이터를 입력해주세요.');
                return;
            }

            try {
                const problemSet = JSON.parse(jsonText);
                
                // 기본 구조 검증
                if (!problemSet.title || !problemSet.description || !problemSet.questions) {
                    alert('JSON 형식이 올바르지 않습니다. title, description, questions 필드가 필요합니다.');
                    return;
                }

                // API에 저장
                if (editingProblemSetKey) {
                    // 편집 모드
                    await updateProblemSetInAPI(key, problemSet);
                    examData[key] = problemSet; // 로컬 캐시 업데이트
                } else {
                    // 새로 생성
                    await saveProblemSetToAPI(key, problemSet);
                    examData[key] = problemSet; // 로컬 캐시에 추가
                }

                alert('문제집이 저장되었습니다.');
                hideAddProblemSetForm();
                await loadProblemSetsIndex(); // 인덱스 새로고침
                await loadProblemSetsManagement();
                await loadExamList(); // 시험 목록 새로고침

            } catch (error) {
                if (error.message.includes('already exists')) {
                    alert('이미 존재하는 문제집 키입니다.');
                } else {
                    alert('문제집 저장 중 오류가 발생했습니다: ' + error.message);
                }
            }
        }

        function getCustomProblemSets() {
            // For backward compatibility, check localStorage
            const stored = localStorage.getItem('custom_problem_sets');
            return stored ? JSON.parse(stored) : {};
        }

        function getAllProblemSets() {
            return examData;
        }

        function editProblemSet(key) {
            const allSets = getAllProblemSets();
            const problemSet = allSets[key];
            
            if (!problemSet) {
                alert('문제집을 찾을 수 없습니다.');
                return;
            }

            editingProblemSetKey = key;
            document.getElementById('formTitle').textContent = '✏️ 문제집 편집';
            document.getElementById('problemSetKey').value = key;
            document.getElementById('problemSetJSON').value = JSON.stringify(problemSet, null, 2);
            document.getElementById('saveBtn').textContent = '수정 저장';
            document.getElementById('addProblemSetForm').classList.remove('hidden');
        }

        async function deleteProblemSet(key) {
            const problemSetInfo = problemSetsIndex.problem_sets.find(ps => ps.key === key);
            
            if (problemSetInfo && problemSetInfo.is_built_in) {
                alert('기본 문제집은 삭제할 수 없습니다.');
                return;
            }

            if (confirm(`'${key}' 문제집을 삭제하시겠습니까?`)) {
                try {
                    await deleteProblemSetFromAPI(key);
                    delete examData[key]; // 로컬 캐시에서 제거
                    
                    await loadProblemSetsIndex(); // 인덱스 새로고침
                    await loadProblemSetsManagement();
                    await loadExamList(); // 시험 목록 새로고침
                    alert('문제집이 삭제되었습니다.');
                } catch (error) {
                    alert('문제집 삭제 중 오류가 발생했습니다: ' + error.message);
                }
            }
        }

        async function loadProblemSetsManagement() {
            const container = document.getElementById('problemSetsManagement');
            container.innerHTML = '';
            
            if (!problemSetsIndex) {
                container.innerHTML = '<p>문제집 목록을 불러오는 중...</p>';
                return;
            }
            
            for (const problemSetInfo of problemSetsIndex.problem_sets) {
                const key = problemSetInfo.key;
                const exam = examData[key];
                
                if (!exam) {
                    // 아직 로드되지 않은 문제집은 로드
                    await loadProblemSet(key);
                }
                
                const setDiv = document.createElement('div');
                setDiv.style.cssText = 'border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; margin: 10px 0; background: #f8fafc;';
                
                const questionCount = examData[key] ? getTotalQuestionCount(examData[key].questions) : '?';
                
                setDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4>${problemSetInfo.title} ${problemSetInfo.is_built_in ? '(기본)' : '(커스텀)'}</h4>
                            <p style="color: #718096; margin: 5px 0;">${problemSetInfo.description}</p>
                            <small style="color: #a0aec0;">키: ${key} | 문제 수: ${questionCount}</small>
                        </div>
                        <div>
                            <button onclick="editProblemSet('${key}')" style="background: #4299e1; color: white; border: none; padding: 8px 12px; border-radius: 4px; margin: 0 5px; cursor: pointer;">편집</button>
                            ${!problemSetInfo.is_built_in ? `<button onclick="deleteProblemSet('${key}')" style="background: #e53e3e; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">삭제</button>` : ''}
                        </div>
                    </div>
                `;
                
                container.appendChild(setDiv);
            }
        }

        async function loadExamList() {
            const examGrid = document.getElementById('examGrid');
            examGrid.innerHTML = '';

            if (!problemSetsIndex || !problemSetsIndex.problem_sets) {
                console.log('Problem sets index not available, trying to reload...');
                
                // Try to reload the problem sets index
                try {
                    problemSetsIndex = await loadProblemSetsIndex();
                } catch (error) {
                    console.error('Failed to reload problem sets index:', error);
                    examGrid.innerHTML = '<p style="color: #e53e3e;">문제집을 불러오는데 실패했습니다. 새로고침해보세요.</p>';
                    return;
                }
                
                if (!problemSetsIndex || !problemSetsIndex.problem_sets) {
                    examGrid.innerHTML = '<p style="color: #e53e3e;">문제집 목록을 불러올 수 없습니다.</p>';
                    return;
                }
            }

            console.log('Loading exam list with', problemSetsIndex.problem_sets.length, 'problem sets');

            for (const problemSetInfo of problemSetsIndex.problem_sets) {
                const key = problemSetInfo.key;
                
                const examCard = document.createElement('div');
                examCard.className = 'exam-card';
                examCard.onclick = () => startExam(key);
                
                examCard.innerHTML = `
                    <h3>${problemSetInfo.title}</h3>
                    <p>${problemSetInfo.description}</p>
                    <p><strong>카테고리:</strong> ${problemSetInfo.category || 'general'}</p>
                `;
                
                examGrid.appendChild(examCard);
            }
        }

        function getTotalQuestionCount(questions) {
            let count = 0;
            questions.forEach(q => {
                if (q.type === 'compound') {
                    count += q.sub_questions.length;
                } else {
                    count += 1;
                }
            });
            return count;
        }

        async function startExam(examKey) {
            // 문제집이 로드되지 않았다면 로드
            if (!examData[examKey]) {
                await loadProblemSet(examKey);
            }
            
            currentExam = examData[examKey];
            if (!currentExam) {
                alert('문제집을 불러올 수 없습니다.');
                return;
            }
            
            userAnswers = {};
            shuffledOptionsMap = {}; // 섞인 선택지 매핑 초기화
            
            document.getElementById('examSelector').classList.add('hidden');
            document.getElementById('examContainer').classList.remove('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
            
            document.getElementById('examTitle').textContent = currentExam.title;
            document.getElementById('totalQuestions').textContent = getTotalQuestionCount(currentExam.questions);
            
            renderQuestions();
            updateProgress();
        }

        function renderQuestions() {
            const container = document.getElementById('questionContainer');
            container.innerHTML = '';
            
            let questionNumber = 1;
            
            currentExam.questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question-container';
                
                if (question.type === 'compound') {
                    questionDiv.innerHTML = `
                        <div class="question-header">
                            <span class="question-number">${questionNumber}</span>
                            <span class="question-score">${question.score}점</span>
                        </div>
                        <div class="question-text">${question.question}</div>
                        <div class="sub-questions">
                            ${question.sub_questions.map((subQ, subIndex) => {
                                const subQuestionHtml = renderSubQuestion(subQ, `${question.id}-${subIndex}`, questionNumber + subIndex);
                                return `<div class="sub-question">${subQuestionHtml}</div>`;
                            }).join('')}
                        </div>
                    `;
                    questionNumber += question.sub_questions.length;
                } else {
                    questionDiv.innerHTML = renderSingleQuestion(question, questionNumber);
                    questionNumber++;
                }
                
                container.appendChild(questionDiv);
            });
            
            setTimeout(renderMath, 100);
        }

        function renderSingleQuestion(question, questionNumber) {
            const questionId = question.id;
            
            let optionsHtml = '';
            
            switch (question.type) {
                case 'single_choice':
                    const shuffledSingleOptions = shuffleOptionsWithMapping(question.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSingleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="radio" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'multiple_choice':
                    const shuffledMultipleOptions = shuffleOptionsWithMapping(question.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledMultipleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="checkbox" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'true_false':
                    optionsHtml = `
                        <div class="options">
                            <div class="option">
                                <input type="radio" id="q${questionId}_true" name="q${questionId}" value="true">
                                <label for="q${questionId}_true">참</label>
                            </div>
                            <div class="option">
                                <input type="radio" id="q${questionId}_false" name="q${questionId}" value="false">
                                <label for="q${questionId}_false">거짓</label>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'short_answer':
                case 'essay':
                    optionsHtml = `
                        <textarea class="text-answer" id="q${questionId}" placeholder="답안을 입력하세요..."></textarea>
                    `;
                    break;
            }
            
            return `
                <div class="question-header">
                    <span class="question-number">${questionNumber}</span>
                    <span class="question-score">${question.score}점</span>
                </div>
                <div class="question-text">${question.question}</div>
                ${optionsHtml}
            `;
        }

        function renderSubQuestion(subQuestion, questionId, questionNumber) {
            let optionsHtml = '';
            
            switch (subQuestion.type) {
                case 'single_choice':
                    const shuffledSubSingleOptions = shuffleOptionsWithMapping(subQuestion.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSubSingleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="radio" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'multiple_choice':
                    const shuffledSubMultipleOptions = shuffleOptionsWithMapping(subQuestion.options, questionId);
                    optionsHtml = `
                        <div class="options">
                            ${shuffledSubMultipleOptions.map((option, index) => `
                                <div class="option">
                                    <input type="checkbox" id="q${questionId}_${index}" name="q${questionId}" value="${index}">
                                    <label for="q${questionId}_${index}">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                    
                case 'true_false':
                    optionsHtml = `
                        <div class="options">
                            <div class="option">
                                <input type="radio" id="q${questionId}_true" name="q${questionId}" value="true">
                                <label for="q${questionId}_true">참</label>
                            </div>
                            <div class="option">
                                <input type="radio" id="q${questionId}_false" name="q${questionId}" value="false">
                                <label for="q${questionId}_false">거짓</label>
                            </div>
                        </div>
                    `;
                    break;
                    
                case 'short_answer':
                case 'essay':
                    optionsHtml = `
                        <textarea class="text-answer" id="q${questionId}" placeholder="답안을 입력하세요..."></textarea>
                    `;
                    break;
            }
            
            return `
                <div class="question-header">
                    <span class="question-number">${questionNumber}</span>
                    <span class="question-score">${subQuestion.score}점</span>
                </div>
                <div class="question-text">${subQuestion.question}</div>
                ${optionsHtml}
            `;
        }

        function updateProgress() {
            document.getElementById('progressFill').style.width = '0%';
        }

        async function submitAnswers() {
            const submitBtn = document.getElementById('submitBtn');
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="loading"></span> 채점 중...';
            
            // 답안 수집
            collectAnswers();
            
            // 채점 수행
            const results = await gradeAnswers();
            
            // 결과 표시
            showResults(results);
            
            submitBtn.disabled = false;
            submitBtn.innerHTML = '답안 제출';
        }

        function collectAnswers() {
            userAnswers = {};
            
            currentExam.questions.forEach((question, index) => {
                if (question.type === 'compound') {
                    question.sub_questions.forEach((subQ, subIndex) => {
                        const questionId = `${question.id}-${subIndex}`;
                        userAnswers[questionId] = collectSingleAnswer(subQ, questionId);
                    });
                } else {
                    userAnswers[question.id] = collectSingleAnswer(question, question.id);
                }
            });
        }

        function collectSingleAnswer(question, questionId) {
            switch (question.type) {
                case 'single_choice':
                    const radio = document.querySelector(`input[name="q${questionId}"]:checked`);
                    if (radio) {
                        const shuffledIndex = parseInt(radio.value);
                        // 섞인 인덱스를 원본 인덱스로 변환
                        const mapping = shuffledOptionsMap[questionId];
                        return mapping ? mapping.shuffledToOriginal[shuffledIndex] : shuffledIndex;
                    }
                    return null;
                    
                case 'multiple_choice':
                    const checkboxes = document.querySelectorAll(`input[name="q${questionId}"]:checked`);
                    const shuffledIndices = Array.from(checkboxes).map(cb => parseInt(cb.value));
                    // 섞인 인덱스들을 원본 인덱스들로 변환
                    const mapping = shuffledOptionsMap[questionId];
                    if (mapping) {
                        return shuffledIndices.map(index => mapping.shuffledToOriginal[index]);
                    }
                    return shuffledIndices;
                    
                case 'true_false':
                    const tfRadio = document.querySelector(`input[name="q${questionId}"]:checked`);
                    return tfRadio ? tfRadio.value : null;
                    
                case 'short_answer':
                case 'essay':
                    const textarea = document.getElementById(`q${questionId}`);
                    return textarea ? textarea.value.trim() : '';
                    
                default:
                    return null;
            }
        }

        async function gradeAnswers() {
            const results = {};
            
            for (const question of currentExam.questions) {
                if (question.type === 'compound') {
                    for (let subIndex = 0; subIndex < question.sub_questions.length; subIndex++) {
                        const subQ = question.sub_questions[subIndex];
                        const questionId = `${question.id}-${subIndex}`;
                        const userAnswer = userAnswers[questionId];
                        
                        if (subQ.type === 'essay') {
                            results[questionId] = await gradeEssayQuestion(subQ, userAnswer);
                        } else {
                            results[questionId] = gradeObjectiveQuestion(subQ, userAnswer);
                        }
                    }
                } else {
                    const questionId = question.id;
                    const userAnswer = userAnswers[questionId];
                    
                    if (question.type === 'essay') {
                        results[questionId] = await gradeEssayQuestion(question, userAnswer);
                    } else {
                        results[questionId] = gradeObjectiveQuestion(question, userAnswer);
                    }
                }
            }
            
            return results;
        }

        function gradeObjectiveQuestion(question, userAnswer) {
            let isCorrect = false;
            let score = 0;
            
            switch (question.type) {
                case 'single_choice':
                    isCorrect = parseInt(userAnswer) === question.correct_answer;
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'multiple_choice':
                    const correctAnswers = question.correct_answers.sort();
                    const userAnswersSorted = (userAnswer || []).sort();
                    isCorrect = JSON.stringify(correctAnswers) === JSON.stringify(userAnswersSorted);
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'true_false':
                    const correctAnswer = question.correct_answer.toString();
                    isCorrect = userAnswer === correctAnswer;
                    score = isCorrect ? question.score : 0;
                    break;
                    
                case 'short_answer':
                    isCorrect = userAnswer && userAnswer.toLowerCase() === question.correct_answer.toLowerCase();
                    score = isCorrect ? question.score : 0;
                    break;
            }
            
            return {
                isCorrect,
                score,
                maxScore: question.score,
                userAnswer,
                correctAnswer: question.correct_answer || question.correct_answers,
                explanation: question.explanation
            };
        }

        async function gradeEssayQuestion(question, userAnswer) {
            if (!apiKey) {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer,
                    explanation: question.explanation,
                    feedback: "API 키가 설정되지 않아 주관식 문제를 채점할 수 없습니다."
                };
            }

            if (!userAnswer || userAnswer.trim() === '') {
                return {
                    isCorrect: false,
                    score: 0,
                    maxScore: question.score,
                    userAnswer: '',
                    explanation: question.explanation,
                    feedback: "답안이 입력되지 않았습니다."
                };
            }

            // 브라우저 제한으로 인해 직접 OpenAI API 호출이 어려우므로 
            // 임시로 간단한 키워드 기반 채점을 사용합니다.
            return gradeEssaySimple(question, userAnswer);
        }

        function gradeEssaySimple(question, userAnswer) {
            // 간단한 키워드 기반 채점 시스템
            const answerLower = userAnswer.toLowerCase();
            let score = 0;
            let feedback = "";
            
            // 기본 점수 (답안을 작성했으면 기본점수 부여)
            if (userAnswer.length > 10) {
                score = Math.floor(question.score * 0.3); // 30% 기본점수
                feedback = "답안을 성실히 작성했습니다. ";
            }
            
            // 문제별 키워드 채점
            if (question.question.includes("피타고라스")) {
                const keywords = ["a²+b²=c²", "a^2+b^2=c^2", "직각삼각형", "빗변", "제곱", "루트"];
                let keywordCount = 0;
                keywords.forEach(keyword => {
                    if (answerLower.includes(keyword.toLowerCase())) {
                        keywordCount++;
                    }
                });
                
                if (keywordCount >= 3) {
                    score = question.score; // 만점
                    feedback += "피타고라스 정리를 정확히 이해하고 계산을 올바르게 수행했습니다.";
                } else if (keywordCount >= 2) {
                    score = Math.floor(question.score * 0.7); // 70%
                    feedback += "피타고라스 정리의 개념은 이해했으나 설명이 부족합니다.";
                } else if (keywordCount >= 1) {
                    score = Math.floor(question.score * 0.5); // 50%
                    feedback += "피타고라스 정리에 대한 기본 이해는 있으나 더 자세한 설명이 필요합니다.";
                }
            }
            
            else if (question.question.includes("뉴턴") && question.question.includes("제3법칙")) {
                const keywords = ["작용", "반작용", "같은", "크기", "반대", "방향", "힘", "법칙"];
                let keywordCount = 0;
                keywords.forEach(keyword => {
                    if (answerLower.includes(keyword.toLowerCase())) {
                        keywordCount++;
                    }
                });
                
                if (keywordCount >= 4) {
                    score = question.score;
                    feedback += "뉴턴 제3법칙을 정확히 설명했습니다.";
                } else if (keywordCount >= 2) {
                    score = Math.floor(question.score * 0.7);
                    feedback += "뉴턴 제3법칙의 기본 개념은 맞으나 더 정확한 설명이 필요합니다.";
                }
            }
            
            // 답안 길이에 따른 추가 점수 조정
            if (userAnswer.length < 20) {
                score = Math.min(score, Math.floor(question.score * 0.4));
                feedback += " 답안이 너무 짧습니다.";
            } else if (userAnswer.length > 100) {
                feedback += " 상세한 답안을 작성했습니다.";
            }
            
            return {
                isCorrect: score === question.score,
                score: Math.min(score, question.score),
                maxScore: question.score,
                userAnswer,
                explanation: question.explanation,
                feedback: feedback || "답안을 검토해보세요."
            };
        }

        // OpenAI API 사용을 위한 프록시 함수 (선택사항)
        async function gradeEssayWithAPI(question, userAnswer) {
            try {
                // CORS 우회를 위한 프록시 서비스 사용 예시
                // 실제 사용시에는 자체 프록시 서버 구축 권장
                const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
                const targetUrl = 'https://api.openai.com/v1/chat/completions';
                
                const response = await fetch(proxyUrl + targetUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey,
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify({
                        model: 'gpt-3.5-turbo',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are an exam grader. Evaluate the student answer and respond with JSON: {"score": number, "feedback": "string", "isCorrect": boolean}'
                            },
                            {
                                role: 'user',
                                content: `Question: ${question.question}\nCorrect Answer Reference: ${question.explanation}\nStudent Answer: ${userAnswer}\nMax Score: ${question.score}`
                            }
                        ],
                        temperature: 0.3
                    })
                });

                if (!response.ok) {
                    throw new Error('API request failed');
                }

                const data = await response.json();
                const aiResponse = JSON.parse(data.choices[0].message.content);
                
                return {
                    isCorrect: aiResponse.score === question.score,
                    score: aiResponse.score,
                    maxScore: question.score,
                    userAnswer,
                    explanation: question.explanation,
                    feedback: aiResponse.feedback
                };
            } catch (error) {
                console.error('AI grading error:', error);
                // API 실패시 간단 채점으로 fallback
                return gradeEssaySimple(question, userAnswer);
            }
        }

        function showResults(results) {
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.remove('hidden');
            
            let totalScore = 0;
            let maxTotalScore = 0;
            
            // 점수 계산
            for (const result of Object.values(results)) {
                totalScore += result.score;
                maxTotalScore += result.maxScore;
            }
            
            // 점수 표시
            const percentage = Math.round((totalScore / maxTotalScore) * 100);
            document.getElementById('finalScore').textContent = `${totalScore}/${maxTotalScore}점 (${percentage}%)`;
            
            let scoreDescription = '';
            if (percentage >= 90) {
                scoreDescription = '🎉 훌륭합니다! 매우 우수한 성적입니다.';
            } else if (percentage >= 80) {
                scoreDescription = '👏 잘했습니다! 좋은 성적입니다.';
            } else if (percentage >= 70) {
                scoreDescription = '👍 괜찮습니다! 조금만 더 노력하면 됩니다.';
            } else if (percentage >= 60) {
                scoreDescription = '📚 더 공부가 필요합니다.';
            } else {
                scoreDescription = '💪 포기하지 말고 다시 도전해보세요!';
            }
            document.getElementById('scoreDescription').textContent = scoreDescription;
            
            // 답안 검토 표시
            const reviewsContainer = document.getElementById('answerReviews');
            reviewsContainer.innerHTML = '';
            
            let questionNumber = 1;
            
            currentExam.questions.forEach((question) => {
                if (question.type === 'compound') {
                    const compoundDiv = document.createElement('div');
                    compoundDiv.innerHTML = `<h3>${question.question}</h3>`;
                    
                    question.sub_questions.forEach((subQ, subIndex) => {
                        const questionId = `${question.id}-${subIndex}`;
                        const result = results[questionId];
                        
                        const reviewDiv = createAnswerReview(subQ, result, questionNumber);
                        compoundDiv.appendChild(reviewDiv);
                        questionNumber++;
                    });
                    
                    reviewsContainer.appendChild(compoundDiv);
                } else {
                    const result = results[question.id];
                    const reviewDiv = createAnswerReview(question, result, questionNumber);
                    reviewsContainer.appendChild(reviewDiv);
                    questionNumber++;
                }
            });
            
            setTimeout(renderMath, 100);
        }

        function createAnswerReview(question, result, questionNumber) {
            const reviewDiv = document.createElement('div');
            
            let statusClass = 'incorrect';
            let statusText = '틀림';
            
            if (result.isCorrect) {
                statusClass = 'correct';
                statusText = '정답';
            } else if (result.score > 0) {
                statusClass = 'partial';
                statusText = '부분 정답';
            }
            
            reviewDiv.className = `answer-review ${statusClass}`;
            
            let userAnswerText = '';
            if (question.type === 'multiple_choice') {
                const selectedOptions = (result.userAnswer || []).map(index => question.options[index]);
                userAnswerText = selectedOptions.length > 0 ? selectedOptions.join(', ') : '선택하지 않음';
            } else if (question.type === 'single_choice') {
                userAnswerText = result.userAnswer !== null ? question.options[result.userAnswer] : '선택하지 않음';
            } else if (question.type === 'true_false') {
                userAnswerText = result.userAnswer === 'true' ? '참' : result.userAnswer === 'false' ? '거짓' : '선택하지 않음';
            } else {
                userAnswerText = result.userAnswer || '답안 없음';
            }
            
            let correctAnswerText = '';
            if (question.type === 'multiple_choice') {
                correctAnswerText = question.correct_answers.map(index => question.options[index]).join(', ');
            } else if (question.type === 'single_choice') {
                correctAnswerText = question.options[question.correct_answer];
            } else if (question.type === 'true_false') {
                correctAnswerText = question.correct_answer ? '참' : '거짓';
            } else if (question.type === 'short_answer') {
                correctAnswerText = question.correct_answer;
            } else {
                correctAnswerText = '주관식 문제';
            }
            
            reviewDiv.innerHTML = `
                <div class="status-badge ${statusClass}">${statusText} (${result.score}/${result.maxScore}점)</div>
                <h4>문제 ${questionNumber}: ${question.question}</h4>
                <p><strong>내 답안:</strong> ${userAnswerText}</p>
                ${question.type !== 'essay' ? `<p><strong>정답:</strong> ${correctAnswerText}</p>` : ''}
                ${result.feedback ? `<p><strong>AI 피드백:</strong> ${result.feedback}</p>` : ''}
                <div class="explanation">
                    <strong>해설:</strong> ${result.explanation}
                </div>
            `;
            
            return reviewDiv;
        }

        function resetExam() {
            currentExam = null;
            userAnswers = {};
            shuffledOptionsMap = {}; // 섞인 선택지 매핑 초기화
            
            document.getElementById('examSelector').classList.remove('hidden');
            document.getElementById('examContainer').classList.add('hidden');
            document.getElementById('resultsContainer').classList.add('hidden');
        }
    </script>
</body>
</html>
